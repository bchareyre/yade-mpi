# encoding: utf-8
#
# utility functions for yade
#
# 2008 © Václav Šmilauer <eudoxos@arcig.cz>

#from yade._utils import *

import math,random
from yade.wrapper import *
try: # use psyco if available
	import psyco
	psyco.full()
except ImportError: pass

# c++ implementations for performance reasons
from yade._utils import *


def sphere(center,radius,density=1,young=30e9,poisson=.3,frictionAngle=0.5236,dynamic=True,wire=False,color=[1,1,1],physParamsClass='BodyMacroParameters'):
	"""Create default sphere, with given parameters. Physical properties such as mass and inertia are calculated automatically."""
	s=Body()
	s.shape=GeometricalModel('Sphere',{'radius':radius,'diffuseColor':color,'wire':wire,'visible':True})
	s.mold=InteractingGeometry('InteractingSphere',{'radius':radius,'diffuseColor':color})
	V=(4./3)*math.pi*radius**3
	inert=(2./5.)*V*density*radius**2
	s.phys=PhysicalParameters(physParamsClass,{'se3':[center[0],center[1],center[2],1,0,0,0],'refSe3':[center[0],center[1],center[2],1,0,0,0],'mass':V*density,'inertia':[inert,inert,inert],'young':young,'poisson':poisson,'frictionAngle':frictionAngle})
	s.bound=BoundingVolume('AABB',{'diffuseColor':[0,1,0]})
	s['isDynamic']=dynamic
	return s

def box(center,extents,orientation=[1,0,0,0],density=1,young=30e9,poisson=.3,frictionAngle=0.5236,dynamic=True,wire=False,color=[1,1,1],physParamsClass='BodyMacroParameters'):
	"""Create default box (cuboid), with given parameters. Physical properties such as mass and inertia are calculated automatically."""
	b=Body()
	b.shape=GeometricalModel('Box',{'extents':extents,'diffuseColor':color,'wire':wire,'visible':True})
	b.mold=InteractingGeometry('InteractingBox',{'extents':extents,'diffuseColor':color})
	mass=8*extents[0]*extents[1]*extents[2]*density
	b.phys=PhysicalParameters(physParamsClass,{'se3':[center[0],center[1],center[2],orientation[0],orientation[1],orientation[2],orientation[3]],'refSe3':[center[0],center[1],center[2],orientation[0],orientation[1],orientation[2],orientation[3]],'mass':mass,'inertia':[mass*4*(extents[1]**2+extents[2]**2),mass*4*(extents[0]**2+extents[2]**2),mass*4*(extents[0]**2+extents[1]**2)],'young':young,'poisson':poisson,'frictionAngle':frictionAngle})
	b.bound=BoundingVolume('AABB',{'diffuseColor':[0,1,0]})
	b['isDynamic']=dynamic
	return b

def facet(vertices,young=30e9,poisson=.3,frictionAngle=0.5236,dynamic=False,wire=True,color=[1,1,1],physParamsClass='BodyMacroParameters'):
	"""Create Facet"""
	b=Body()
	b.shape=GeometricalModel('Facet',{'diffuseColor':color,'wire':wire,'visible':True})
	b.mold=InteractingGeometry('InteractingFacet',{'diffuseColor':color})
	center=inscribedCircleCenter(vertices[0],vertices[1],vertices[2])
	vertices=map(lambda a,b:map(lambda x,y:x-y,a,b),vertices,[center,center,center]) 
	vStr='['+' '.join(['{%g %g %g}'%(v[0],v[1],v[2]) for v in vertices])+']'
	b.shape.setRaw('vertices',vStr)
	b.mold.setRaw('vertices',vStr)
	b.phys=PhysicalParameters(physParamsClass,{'se3':[center[0],center[1],center[2],1,0,0,0],'refSe3':[center[0],center[1],center[2],1,0,0,0],'mass':0,'inertia':[0,0,0],'young':young,'poisson':poisson,'frictionAngle':frictionAngle})
	b.bound=BoundingVolume('AABB',{'diffuseColor':[0,1,0]})
	b['isDynamic']=dynamic
	b.mold.postProcessAttributes()
	return b

def aabbWalls(extrema=None,thickness=None,oversizeFactor=1.5,**kw):
	"""return 6 walls that will wrap existing packing;
	extrema are extremal points of the AABB of the packing (will be calculated if not specified)
	thickness is wall thickness (will be 1/10 of the X-dimension if not specified)
	Walls will be enlarged in their plane by oversizeFactor.
	returns list of 6 wall Bodies enclosing the packing, in the order minX,maxX,minY,maxY,minZ,maxZ.
	"""
	walls=[]
	if not extrema: extrema=aabbExtrema()
	if not thickness: thickness=(extrema[1][0]-extrema[0][0])/10.
	for axis in [0,1,2]:
		mi,ma=extrema
		center=[(mi[i]+ma[i])/2. for i in range(3)]
		extents=[.5*oversizeFactor*(ma[i]-mi[i]) for i in range(3)]
		extents[axis]=thickness/2.
		for j in [0,1]:
			center[axis]=extrema[j][axis]+(j-.5)*thickness
			walls.append(box(center=center,extents=extents,dynamic=False,**kw))
			walls[-1].shape['wire']=True
			walls[-1].shape['visible']=True
	return walls


def aabbDim(cutoff=0.):
	"""return dimensions of the bounding box, optionally cut."""
	a=aabbExtrema(cutoff)
	return (a[1][0]-a[0][0],a[1][1]-a[0][1],a[1][2]-a[0][2])

def perpendicularArea(axis):
	"""return area perpendicular to given axis (0=x,1=y,2=z) generated by bodies
	for which the function consider returns True (defaults to returning True always)
	and which is of the type "Sphere"
	"""
	ext=aabbExtrema()
	other=((axis+1)%3,(axis+2)%3)
	return (ext[1][other[0]]-ext[0][other[0]])*(ext[1][other[1]]-ext[0][other[1]])

def fractionalBox(fraction=1.,minMax=None):
	"""retrurn (min,max) that is the original minMax box (or aabb of the whole simulation if not specified)
	linearly scaled around its center to the fraction factor"""
	if not minMax: minMax=aabbExtrema()
	half=[.5*(minMax[1][i]-minMax[0][i]) for i in [0,1,2]]
	return (tuple([minMax[0][i]+(1-fraction)*half[i] for i in [0,1,2]]),tuple([minMax[1][i]-(1-fraction)*half[i] for i in [0,1,2]]))


def randomizeColors(onShapes=True,onMolds=False,onlyDynamic=False):
	"""Assign random colors to shape's (GeometricalModel) and/or mold's (InteractingGeometry) diffuseColor.
	
	onShapes and onMolds turn on/off operating on the respective colors.
	If onlyDynamic is true, only dynamic bodies will have the color changed.
	"""
	if not onShapes and not onMolds: return
	o=Omega()
	for b in o.bodies:
		color=(random.random(),random.random(),random.random())
		if onShapes and (b['isDynamic'] or not onlyDynamic): b.shape['diffuseColor']=color
		if onMolds  and (b['isDynamic'] or not onlyDynamic): b.mold['diffuseColor']=color


def spheresFromFile(filename,scale=1.,wenjieFormat=False,**kw):
	"""Load sphere coordinates from file, create spheres, insert them to the simulation.

	filename is the file holding ASCII numbers (at least 4 colums that hold x_center, y_center, z_center, radius).
	All remaining arguments are passed the the yade.utils.sphere function that creates the bodies.

	wenjieFormat will skip all lines that have exactly 5 numbers and where the 4th one is exactly 1.0 -
	this was used by a fellow developer called Wenjie to mark box elements.
	
	Returns list of body ids that were inserted into simulation."""
	o=Omega()
	ret=[]
	for l in open(filename):
		ss=[float(i) for i in l.split()]
		if wenjieFormat and len(ss)==5 and ss[4]==1.0: continue
		id=o.bodies.append(sphere([scale*ss[0],scale*ss[1],scale*ss[2]],scale*ss[3],**kw))
		ret.append(id)
	return ret

def spheresToFile(filename,consider=lambda id: True):
	"""Save sphere coordinates into ASCII file; the format of the line is: x y z r.
	Non-spherical bodies are silently skipped."""
	o=Omega()
	out=open(filename,'w')
	for b in o.bodies:
		if not b.shape or not b.shape.name=='Sphere' or not consider(b.id): continue
		out.write('%g\t%g\t%g\t%g\n'%(b.phys['se3'][0],b.phys['se3'][1],b.phys['se3'][2],b.shape['radius']))
	out.close()

def avgNumInteractions(cutoff=0.):
	nums,counts=bodyNumInteractionsHistogram(aabbExtrema(cutoff))
	return sum([nums[i]*counts[i] for i in range(len(nums))])/(1.*sum(counts))

def plotNumInteractionsHistogram(cutoff=0.):
	nums,counts=bodyNumInteractionsHistogram(aabbExtrema(cutoff))
	import pylab
	pylab.bar(nums,counts)
	pylab.title('Number of interactions histogram, average %g (cutoff=%g)'%(avgNumInteractions(cutoff),cutoff))
	pylab.xlabel('Number of interactions')
	pylab.ylabel('Body count')
	pylab.show()

def plotDirections(aabb=(),mask=0,bins=20,numHist=True):
	"""Plot 3 histograms for distribution of interaction directions, in yz,xz and xy planes and
	(optional but default) histogram of number of interactions per body."""
	import pylab,math
	from yade import utils
	for axis in [0,1,2]:
		d=utils.interactionAnglesHistogram(axis,mask=mask,bins=bins,aabb=aabb)
		fc=[0,0,0]; fc[axis]=1.
		subp=pylab.subplot(220+axis+1,polar=True);
		# 1.1 makes small gaps between values (but the column is a bit decentered)
		pylab.bar(d[0],d[1],width=math.pi/(1.1*bins),fc=fc,alpha=.7,label=['yz','xz','xy'][axis])
		#pylab.title(['yz','xz','xy'][axis]+' plane')
		pylab.text(.5,.25,['yz','xz','xy'][axis],horizontalalignment='center',verticalalignment='center',transform=subp.transAxes,fontsize='xx-large')
	if numHist:
		pylab.subplot(224,polar=False)
		nums,counts=utils.bodyNumInteractionsHistogram(aabb if len(aabb)>0 else utils.aabbExtrema())
		avg=sum([nums[i]*counts[i] for i in range(len(nums))])/(1.*sum(counts))
		pylab.bar(nums,counts,fc=[1,1,0],alpha=.7,align='center')
		pylab.xlabel('Interactions per body (avg. %g)'%avg)
		pylab.axvline(x=avg,linewidth=3,color='r')
		pylab.ylabel('Body count')
	pylab.show()


def import_stl_geometry(file, begin=0, young=30e9,poisson=.3,frictionAngle=0.5236,wire=True):
		## Import walls geometry from STL file
		imp = STLImporter()
		imp.wire = wire
		imp.open(file)
		o=Omega()
		for i in xrange(imp.number_of_facets):
			b=Body()
			b['isDynamic']=False
			b.phys=PhysicalParameters('BodyMacroParameters',{'se3':[0,0,0,1,0,0,0],'mass':0,'inertia':[0,0,0],'young':young,'poisson':poisson,'frictionAngle':frictionAngle})
			b.bound=BoundingVolume('AABB',{'diffuseColor':[0,1,0]})
			o.bodies.append(b)
		imp.import_geometry(o.bodies,begin)
		for i in xrange(begin,begin+imp.number_of_facets):
			o.bodies[i].mold.postProcessAttributes()
		return imp.number_of_facets

