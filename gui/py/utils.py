# encoding: utf-8
#
# utility functions for yade
#
# 2008 © Václav Šmilauer <eudoxos@arcig.cz>

import math,random
from yade.wrapper import *
try: # use psyco if available
	import psyco
	psyco.full()
except ImportError: pass

def sphere(center,radius,density=1,young=30e9,poisson=.3,frictionAngle=0.5236,dynamic=True,wire=False,color=[1,1,1]):
	"""Create default sphere, with given parameters. Physical properties such as mass and inertia are calculated automatically."""
	s=Body()
	s.shape=GeometricalModel('Sphere',{'radius':radius,'diffuseColor':color,'wire':wire,'visible':True})
	s.mold=InteractingGeometry('InteractingSphere',{'radius':radius,'diffuseColor':color})
	V=(4./3)*math.pi*radius**3
	inert=(2./5.)*V*density*radius**2
	s.phys=PhysicalParameters('BodyMacroParameters',{'se3':[center[0],center[1],center[2],1,0,0,0],'mass':V*density,'inertia':[inert,inert,inert],'young':young,'poisson':poisson,'frictionAngle':frictionAngle})
	s.bound=BoundingVolume('AABB',{'diffuseColor':[0,1,0]})
	s['isDynamic']=dynamic
	return s

def box(center,extents,orientation=[1,0,0,0],density=1,young=30e9,poisson=.3,frictionAngle=0.5236,dynamic=True,wire=False,color=[1,1,1]):
	"""Create default box (cuboid), with given parameters. Physical properties such as mass and inertia are calculated automatically."""
	b=Body()
	b.shape=GeometricalModel('Box',{'extents':extents,'diffuseColor':color,'wire':wire,'visible':True})
	b.mold=InteractingGeometry('InteractingBox',{'extents':extents,'diffuseColor':color})
	mass=8*extents[0]*extents[1]*extents[2]*density
	b.phys=PhysicalParameters('BodyMacroParameters',{'se3':[center[0],center[1],center[2],orientation[0],orientation[1],orientation[2],orientation[3]],'mass':mass,'inertia':[mass*4*(extents[1]**2+extents[2]**2),mass*4*(extents[0]**2+extents[2]**2),mass*4*(extents[0]**2+extents[1]**2)],'young':young,'poisson':poisson,'frictionAngle':frictionAngle})
	b.bound=BoundingVolume('AABB',{'diffuseColor':[0,1,0]})
	b['isDynamic']=dynamic
	return b

def negPosExtremes(axis,distFactor=1.1):
	"""Get 2 lists (negative and positive extremes) of sphere ids that are close to the boundary
	in the direction of requested axis (0=x,1=y,2=z).

	distFactor enlarges radius of the sphere, it can be considered 'extremal' even if it doesn't touch the extreme.
	"""
	inf=float('inf')
	extremes=[inf,-inf]
	ret=[[],[]]
	o=Omega()
	for b in o.bodies:
		extremes[1]=max(extremes[1],+b.shape['radius']+b.phys['se3'][axis])
		extremes[0]=min(extremes[0],-b.shape['radius']+b.phys['se3'][axis])
	for b in o.bodies:
		if b.phys['se3'][axis]-b.shape['radius']*distFactor<=extremes[0]: ret[0].append(b.id)
		if b.phys['se3'][axis]+b.shape['radius']*distFactor>=extremes[1]: ret[1].append(b.id)
	return ret

def aabbWalls(extrema=None,thickness=None,oversizeFactor=1.5,**kw):
	"""return 6 walls that will wrap existing packing;
	extrema are extremal points of the AABB of the packing (will be calculated if not specified)
	thickness is wall thickness (will be 1/10 of the X-dimension if not specified)
	Walls will be enlarged in their plane by oversizeFactor.
	returns list of 6 wall Bodies enclosing the packing, in the order minX,maxX,minY,maxY,minZ,maxZ.
	"""
	walls=[]
	if not extrema: extrema=aabbExtrema()
	if not thickness: thickness=(extrema[1][0]-extrema[0][0])/10.
	for axis in [0,1,2]:
		mi,ma=extrema
		center=[(mi[i]+ma[i])/2. for i in range(3)]
		extents=[.5*oversizeFactor*(ma[i]-mi[i]) for i in range(3)]
		extents[axis]=thickness/2.
		for j in [0,1]:
			center[axis]=extrema[j][axis]+(j-.5)*thickness
			walls.append(box(center=center,extents=extents,dynamic=False,**kw))
			walls[-1].shape['wire']=True
			walls[-1].shape['visible']=True
	return walls


def aabbExtrema(consider=lambda body:True):
	"""return min and max points of an aabb around spherical packing (non-spheres are ignored)"""
	inf=float('inf')
	minimum,maximum=[inf,inf,inf],[-inf,-inf,-inf]
	o=Omega()
	for b in o.bodies:
		if consider(b) and b.shape.name=='Sphere':
			minimum=[min(minimum[i],b.phys['se3'][i]-b.shape['radius']) for i in range(3)]
			maximum=[max(maximum[i],b.phys['se3'][i]+b.shape['radius']) for i in range(3)]
	return minimum,maximum

def perpendicularArea(axis,consider=lambda body: True):
	"""return area perpendicular to given axis (0=x,1=y,2=z) generated by bodies
	for which the function consider returns True (defaults to returning True always)
	and which is of the type "Sphere"
	"""
	ext=aabbExtrema(consider)
	other=((axis+1)%3,(axis+2)%3)
	return (ext[1][other[0]]-ext[0][other[0]])*(ext[1][other[1]]-ext[0][other[1]])


def randomizeColors(onShapes=True,onMolds=False,onlyDynamic=False):
	"""Assign random colors to shape's (GeometricalModel) and/or mold's (InteractingGeometry) diffuseColor.
	
	onShapes and onMolds turn on/off operating on the respective colors.
	If onlyDynamic is true, only dynamic bodies will have the color changed.
	"""
	if not onShapes and not onMolds: return
	o=Omega()
	for b in o.bodies:
		color=(random.random(),random.random(),random.random())
		if onShapes and (b['isDynamic'] or not onlyDynamic): b.shape['diffuseColor']=color
		if onMolds  and (b['isDynamic'] or not onlyDynamic): b.mold['diffuseColor']=color

def runInQtGui(background=True):
	raise DeprecationWarning("This  runInQtGui functions is deprecated, since python now coexists with QtGUI.")

def PWaveTimeStep():
	"""Estimate timestep by the elastic wave propagation speed (p-wave).
	
	Multiply the value returned by some safety factor < 1, since shear waves are not taken into account here."""
	o=Omega()
	dt=float('inf')
	for b in o.bodies:
		if not (b.phys and b.shape): continue
		if not (b.phys.has_key('young') and b.shape.has_key('radius')): continue
		density=b.phys['mass']/((4./3.)*math.pi*b.shape['radius']**3)
		thisDt=b.shape['radius']/math.sqrt(b.phys['young']/density)
		dt=min(dt,thisDt)
	return dt

def spheresFromFile(filename,scale=1.,wenjieFormat=False,**kw):
	"""Load sphere coordinates from file, create spheres, insert them to the simulation.

	filename is the file holding ASCII numbers (at least 4 colums that hold x_center, y_center, z_center, radius).
	All remaining arguments are passed the the yade.utils.sphere function that creates the bodies.

	wenjieFormat will skip all lines that have exactly 5 numbers and where the 4th one is exactly 1.0 -
	this was used by a fellow developer called Wenjie to mark box elements.
	
	Returns list of body ids that were inserted into simulation."""
	o=Omega()
	ret=[]
	for l in open(filename):
		ss=[float(i) for i in l.split()]
		if wenjieFormat and len(ss)==5 and ss[4]==1.0: continue
		id=o.bodies.append(sphere([scale*ss[0],scale*ss[1],scale*ss[2]],scale*ss[3],**kw))
		ret.append(id)
	return ret

def spheresToFile(filename,consider=lambda id: True):
	"""Save sphere coordinates into ASCII file; the format of the line is: x y z r.
	Non-spherical bodies are silently skipped."""
	o=Omega()
	out=open(filename,'w')
	for b in o.bodies:
		if not b.shape or not b.shape.name=='Sphere' or not consider(b.id): continue
		out.write('%g\t%g\t%g\t%g\n'%(b.phys['se3'][0],b.phys['se3'][1],b.phys['se3'][2],b.shape['radius']))
	out.close()

def qtCreateVideo(playerDb,out,viewerState,stride,fps=24,postLoadHook=None):
	"""Create video by replaying a simulation. Snapshots are taken to temporary files,
	encoded to a .ogg stream (theora codec); temps are deleted at the end.

	If the output file exists already, a ~[number] is appended and the old file is renamed.

	playerDb is the database with saved simulation states,
	out is the output file (like a.ogg), fps is frames-per-second for the video that is created,
	viewerState, stride and postLoadHook are passed to qt.runPlayer (docs in gui/qt3/QtGUI-Python.cpp).
	
	You need a display to run this (either virtual, like xvfb, or physical).

	Necessary packages: python-gst0.10 gstreamer0.10-plugins-good python-gobject
	"""
	import pygst,sys,gobject,os
	pygst.require("0.10")
	import gst
	from yade import qt
	qt.Player(True)
	# postLoadHook has "" instead of None in the c++ interface
	wildcard,snaps=qt.runPlayer(playerDb,'',viewerState,stride=stride,postLoadHook=(postLoadHook if postLoadHook else ''))
	if(os.path.exists(out)):
		i=0
		while(os.path.exists(out+"~%d"%i)): i+=1
		os.rename(out,out+"~%d"%i); print "Output file `%s' already existed, old file renamed to `%s'"%(out,out+"~%d"%i)
	print "Encoding video from %s (%d files total) to %s"%(wildcard,len(snaps),out)
	pipeline=gst.parse_launch('multifilesrc location="%s" index=0 caps="image/png,framerate=\(fraction\)%d/1" ! pngdec ! ffmpegcolorspace ! theoraenc sharpness=2 quality=32 ! oggmux ! filesink location="%s"'%(wildcard,fps,out))
	bus=pipeline.get_bus()
	bus.add_signal_watch()
	mainloop=gobject.MainLoop();
	bus.connect("message::eos",lambda bus,msg: mainloop.quit())
	pipeline.set_state(gst.STATE_PLAYING)
	mainloop.run()
	pipeline.set_state(gst.STATE_NULL); pipeline.get_state()
	print "Cleaning snapshot files."
	for f in snaps: os.remove(f)

