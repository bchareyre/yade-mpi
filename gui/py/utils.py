# encoding: utf-8
#
# utility functions for yade
#
# 2008 © Václav Šmilauer <eudoxos@arcig.cz>

#from yade._utils import *

import math,random
from yade.wrapper import *
try: # use psyco if available
	import psyco
	psyco.full()
except ImportError: pass

# c++ implementations for performance reasons
from yade._utils import *


def sphere(center,radius,density=1,young=30e9,poisson=.3,frictionAngle=0.5236,dynamic=True,wire=False,color=[1,1,1],physParamsClass='BodyMacroParameters'):
	"""Create default sphere, with given parameters. Physical properties such as mass and inertia are calculated automatically."""
	s=Body()
	s.shape=GeometricalModel('Sphere',{'radius':radius,'diffuseColor':color,'wire':wire,'visible':True})
	s.mold=InteractingGeometry('InteractingSphere',{'radius':radius,'diffuseColor':color})
	V=(4./3)*math.pi*radius**3
	inert=(2./5.)*V*density*radius**2
	s.phys=PhysicalParameters(physParamsClass,{'se3':[center[0],center[1],center[2],1,0,0,0],'refSe3':[center[0],center[1],center[2],1,0,0,0],'mass':V*density,'inertia':[inert,inert,inert],'young':young,'poisson':poisson,'frictionAngle':frictionAngle})
	s.bound=BoundingVolume('AABB',{'diffuseColor':[0,1,0]})
	s['isDynamic']=dynamic
	return s

def box(center,extents,orientation=[1,0,0,0],density=1,young=30e9,poisson=.3,frictionAngle=0.5236,dynamic=True,wire=False,color=[1,1,1],physParamsClass='BodyMacroParameters'):
	"""Create default box (cuboid), with given parameters. Physical properties such as mass and inertia are calculated automatically."""
	b=Body()
	b.shape=GeometricalModel('Box',{'extents':extents,'diffuseColor':color,'wire':wire,'visible':True})
	b.mold=InteractingGeometry('InteractingBox',{'extents':extents,'diffuseColor':color})
	mass=8*extents[0]*extents[1]*extents[2]*density
	b.phys=PhysicalParameters(physParamsClass,{'se3':[center[0],center[1],center[2],orientation[0],orientation[1],orientation[2],orientation[3]],'refSe3':[center[0],center[1],center[2],orientation[0],orientation[1],orientation[2],orientation[3]],'mass':mass,'inertia':[mass*4*(extents[1]**2+extents[2]**2),mass*4*(extents[0]**2+extents[2]**2),mass*4*(extents[0]**2+extents[1]**2)],'young':young,'poisson':poisson,'frictionAngle':frictionAngle})
	b.bound=BoundingVolume('AABB',{'diffuseColor':[0,1,0]})
	b['isDynamic']=dynamic
	return b

def facet(vertices,young=30e9,poisson=.3,frictionAngle=0.5236,dynamic=False,wire=True,color=[1,1,1],physParamsClass='BodyMacroParameters'):
	"""Create Facet"""
	b=Body()
	b.shape=GeometricalModel('Facet',{'diffuseColor':color,'wire':wire,'visible':True})
	b.mold=InteractingGeometry('InteractingFacet',{'diffuseColor':color})
	center=inscribedCircleCenter(vertices[0],vertices[1],vertices[2])
	vertices=map(lambda a,b:map(lambda x,y:x-y,a,b),vertices,[center,center,center]) 
	vStr='['+' '.join(['{%g %g %g}'%(v[0],v[1],v[2]) for v in vertices])+']'
	b.shape.setRaw('vertices',vStr)
	b.mold.setRaw('vertices',vStr)
	b.phys=PhysicalParameters(physParamsClass,{'se3':[center[0],center[1],center[2],1,0,0,0],'refSe3':[center[0],center[1],center[2],1,0,0,0],'mass':0,'inertia':[0,0,0],'young':young,'poisson':poisson,'frictionAngle':frictionAngle})
	b.bound=BoundingVolume('AABB',{'diffuseColor':[0,1,0]})
	b['isDynamic']=dynamic
	b.mold.postProcessAttributes()
	return b

def aabbWalls(extrema=None,thickness=None,oversizeFactor=1.5,**kw):
	"""return 6 walls that will wrap existing packing;
	extrema are extremal points of the AABB of the packing (will be calculated if not specified)
	thickness is wall thickness (will be 1/10 of the X-dimension if not specified)
	Walls will be enlarged in their plane by oversizeFactor.
	returns list of 6 wall Bodies enclosing the packing, in the order minX,maxX,minY,maxY,minZ,maxZ.
	"""
	walls=[]
	if not extrema: extrema=aabbExtrema()
	if not thickness: thickness=(extrema[1][0]-extrema[0][0])/10.
	for axis in [0,1,2]:
		mi,ma=extrema
		center=[(mi[i]+ma[i])/2. for i in range(3)]
		extents=[.5*oversizeFactor*(ma[i]-mi[i]) for i in range(3)]
		extents[axis]=thickness/2.
		for j in [0,1]:
			center[axis]=extrema[j][axis]+(j-.5)*thickness
			walls.append(box(center=center,extents=extents,dynamic=False,**kw))
			walls[-1].shape['wire']=True
			walls[-1].shape['visible']=True
	return walls


def aabbDim(cutoff=0.):
	"""return dimensions of the bounding box, optionally cut."""
	a=aabbExtrema(cutoff)
	return (a[1][0]-a[0][0],a[1][1]-a[0][1],a[1][2]-a[0][2])

def perpendicularArea(axis):
	"""return area perpendicular to given axis (0=x,1=y,2=z) generated by bodies
	for which the function consider returns True (defaults to returning True always)
	and which is of the type "Sphere"
	"""
	ext=aabbExtrema()
	other=((axis+1)%3,(axis+2)%3)
	return (ext[1][other[0]]-ext[0][other[0]])*(ext[1][other[1]]-ext[0][other[1]])

def fractionalBox(fraction=1.,minMax=None):
	"""retrurn (min,max) that is the original minMax box (or aabb of the whole simulation if not specified)
	linearly scaled around its center to the fraction factor"""
	if not minMax: minMax=aabbExtrema()
	half=[.5*(minMax[1][i]-minMax[0][i]) for i in [0,1,2]]
	return (tuple([minMax[0][i]+(1-fraction)*half[i] for i in [0,1,2]]),tuple([minMax[1][i]-(1-fraction)*half[i] for i in [0,1,2]]))


def randomizeColors(onShapes=True,onMolds=False,onlyDynamic=False):
	"""Assign random colors to shape's (GeometricalModel) and/or mold's (InteractingGeometry) diffuseColor.
	
	onShapes and onMolds turn on/off operating on the respective colors.
	If onlyDynamic is true, only dynamic bodies will have the color changed.
	"""
	if not onShapes and not onMolds: return
	o=Omega()
	for b in o.bodies:
		color=(random.random(),random.random(),random.random())
		if onShapes and (b['isDynamic'] or not onlyDynamic): b.shape['diffuseColor']=color
		if onMolds  and (b['isDynamic'] or not onlyDynamic): b.mold['diffuseColor']=color


def spheresFromFile(filename,scale=1.,wenjieFormat=False,**kw):
	"""Load sphere coordinates from file, create spheres, insert them to the simulation.

	filename is the file holding ASCII numbers (at least 4 colums that hold x_center, y_center, z_center, radius).
	All remaining arguments are passed the the yade.utils.sphere function that creates the bodies.

	wenjieFormat will skip all lines that have exactly 5 numbers and where the 4th one is exactly 1.0 -
	this was used by a fellow developer called Wenjie to mark box elements.
	
	Returns list of body ids that were inserted into simulation."""
	o=Omega()
	ret=[]
	for l in open(filename):
		ss=[float(i) for i in l.split()]
		if wenjieFormat and len(ss)==5 and ss[4]==1.0: continue
		id=o.bodies.append(sphere([scale*ss[0],scale*ss[1],scale*ss[2]],scale*ss[3],**kw))
		ret.append(id)
	return ret

def spheresToFile(filename,consider=lambda id: True):
	"""Save sphere coordinates into ASCII file; the format of the line is: x y z r.
	Non-spherical bodies are silently skipped."""
	o=Omega()
	out=open(filename,'w')
	for b in o.bodies:
		if not b.shape or not b.shape.name=='Sphere' or not consider(b.id): continue
		out.write('%g\t%g\t%g\t%g\n'%(b.phys['se3'][0],b.phys['se3'][1],b.phys['se3'][2],b.shape['radius']))
	out.close()

def import_stl_geometry(file, begin=0, young=30e9,poisson=.3,frictionAngle=0.5236,wire=True):
		## Import walls geometry from STL file
		imp = STLImporter()
		imp.wire = wire
		imp.open(file)
		o=Omega()
		for i in xrange(imp.number_of_facets):
			b=Body()
			b['isDynamic']=False
			b.phys=PhysicalParameters('BodyMacroParameters',{'se3':[0,0,0,1,0,0,0],'mass':0,'inertia':[0,0,0],'young':young,'poisson':poisson,'frictionAngle':frictionAngle})
			b.bound=BoundingVolume('AABB',{'diffuseColor':[0,1,0]})
			o.bodies.append(b)
		imp.import_geometry(o.bodies,begin)
		for i in xrange(begin,begin+imp.number_of_facets):
			o.bodies[i].mold.postProcessAttributes()
		return imp.number_of_facets

def negPosExtremes(**kw): raise DeprecationWarning("negPosExtremes is deprecated, use negPosExtremalIds instead.")

# reimplemented in _utils in c++ (results verified to be identical)
if 0:
	def negPosExtremes(axis,distFactor=1.1):
		"""Get 2 lists (negative and positive extremes) of sphere ids that are close to the boundary
		in the direction of requested axis (0=x,1=y,2=z).

		distFactor enlarges radius of the sphere, it can be considered 'extremal' even if it doesn't touch the extreme.
		"""
		inf=float('inf')
		extremes=[inf,-inf]
		ret=[[],[]]
		o=Omega()
		for b in o.bodies:
			extremes[1]=max(extremes[1],+b.shape['radius']+b.phys['se3'][axis])
			extremes[0]=min(extremes[0],-b.shape['radius']+b.phys['se3'][axis])
		for b in o.bodies:
			if b.phys['se3'][axis]-b.shape['radius']*distFactor<=extremes[0]: ret[0].append(b.id)
			if b.phys['se3'][axis]+b.shape['radius']*distFactor>=extremes[1]: ret[1].append(b.id)
		return ret
	def aabbExtrema(consider=lambda body:True):
		"""return min and max points of an aabb around spherical packing (non-spheres are ignored)"""
		inf=float('inf')
		minimum,maximum=[inf,inf,inf],[-inf,-inf,-inf]
		o=Omega()
		for b in o.bodies:
			if consider(b) and b.shape.name=='Sphere':
				minimum=[min(minimum[i],b.phys['se3'][i]-b.shape['radius']) for i in range(3)]
				maximum=[max(maximum[i],b.phys['se3'][i]+b.shape['radius']) for i in range(3)]
		return minimum,maximum
	def PWaveTimeStep():
		"""Estimate timestep by the elastic wave propagation speed (p-wave).
		
		Multiply the value returned by some safety factor < 1, since shear waves are not taken into account here."""
		o=Omega()
		dt=float('inf')
		for b in o.bodies:
			if not (b.phys and b.shape): continue
			if not (b.phys.has_key('young') and b.shape.has_key('radius')): continue
			density=b.phys['mass']/((4./3.)*math.pi*b.shape['radius']**3)
			thisDt=b.shape['radius']/math.sqrt(b.phys['young']/density)
			dt=min(dt,thisDt)
		return dt

