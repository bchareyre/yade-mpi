#!/usr/bin/env python
# encoding: utf-8
#
# portions © 2008 Václav Šmilauer <eudoxos@arcig.cz>

import os, sys, thread, time

class JobInfo():
	def __init__(self,num,id,command,log):
		self.started,self.finished,self.duration,self.exitStatus=None,None,None,None
		self.command=command; self.num=num; self.log=log; self.id=id
	def saveInfo(self):
		log=file(self.log,'a')
		log.write("""
=================== JOB SUMMARY ================
id      : %s
status  : %d (%s)
duration: %s
command : %s
started : %s
finished: %s
"""%(self.id,self.exitStatus,'OK' if self.exitStatus==0 else 'FAILED',self.duration,self.command,time.asctime(time.localtime(self.started)),time.asctime(time.localtime(self.finished))));
		log.close()

#
# _MANY_ thanks to Mark Pettit for concurrent jobs handling!
# http://code.activestate.com/recipes/534160/
#


def __concurrent_batch(cmd,thread_num,completion_status_dict,exit_code_dict):
	"""Helper routine for 'concurrent_batches."""
	job=jobs[thread_num]
	job.started=time.time();
	print '#%d started on %s'%(thread_num,time.asctime())
	exit_code_dict[thread_num] = os.system(cmd)
	completion_status_dict[thread_num] = 1  # for sum() routine
	job.finished=time.time(); dt=job.finished-job.started;
	job.exitStatus=exit_code_dict[thread_num]
	job.duration='%02d:%02d:%02d'%(dt//3600,(dt%3600)//60,(dt%60))
	strStatus='done   ' if job.exitStatus==0 else 'FAILED '
	print "#%d %s (exit status %d), duration %s, log %s"%(thread_num,strStatus,exit_code_dict[thread_num],job.duration,job.log)
	job.saveInfo()

def concurrent_batches(batchlist,maxjobs=0,maxtime=0):
	"""Run a list of batch commands simultaneously.

	'batchlist' is a list of strings suitable for submitting under os.system().
	Each job will run in a separate thread, with the thread ending when the
	subprocess ends.
	'maxjobs' will, if greater then zero, be the maximum number of simultaneous
	jobs which can concurrently run.  This would be used to limit the number of
	processes where too many could flood a system, causing performance issues.
	'maxtime', when greater than zero, be the maximum amount of time (seconds)
	that we will wait for processes to complete.  After that, we will return,
	but no jobs will be killed.  In other words, the jobs still running will
	continue to run, and hopefully finish in the course of time.

	example: concurrent_batches(("gzip abc","gzip def","gzip xyz"))

	returns: a dictionary of exit status codes, but only when ALL jobs are
			 complete, or the maximum time has been exceeded.
			 Note that if returning due to exceeding time, the dictionary will
			 continue to be updated by the threads as they complete.
			 The key of the dictionary is the thread number, which matches the
			 index of the list of batch commands.  The value is the result of
			 the os.system call.

	gotcha:  If both the maxjobs and maxtime is set, there is a possibility that
			 not all jobs will be submitted.  The only way to detect this will be
			 by checking for the absence of the KEY in the returned dictionary.
	"""

	if not batchlist: return {}
	completion_status_dict, exit_code_dict = {}, {}
	num_jobs = len(batchlist)
	start_time = time.time()
	for thread_num, cmd in enumerate(batchlist):
		exit_code_dict[thread_num] = None
		completion_status_dict[thread_num] = 0 # for sum() routine
		thread.start_new_thread(__concurrent_batch,
			  (cmd,thread_num,completion_status_dict,exit_code_dict))
		while True:
			completed = sum(completion_status_dict.values())
			if num_jobs == completed:
				return exit_code_dict	  # all done
			running = thread_num - completed + 1
			if maxtime > 0:
				if time.time() - start_time > maxtime:
					return exit_code_dict
			if not maxjobs:
				if thread_num < num_jobs-1:  # have we submitted all jobs ?
					break				  #  no, so break to for cmd loop
				else:
					time.sleep(.2)		 #  yes, so wait until jobs are complete
					continue
			if running < maxjobs and thread_num < num_jobs-1:
				break	# for next for loop
			time.sleep(.2)
#
# now begins the yade code
#

import sys,re,optparse
def getNumCores(): return len([l for l in open('/proc/cpuinfo','r') if l.find('processor')==0])

parser=optparse.OptionParser(usage='%prog [options] TABLE SIMULATION.py\n\n  %prog runs yade simulation multiple times with different parameters.\n  See http://yade.wikia.com/wiki/ScriptParametricStudy for details.')
parser.add_option('-j',dest='maxJobs',type='int',help="Maximum number of simultaneous jobs to run (default: number of cores, i.e. %d)"%getNumCores(),metavar='NUM',default=getNumCores())
parser.add_option('--log',dest='logFormat',help='Format of log files -- must contain a % or @, which will be replaced by line number or by description column respectively (default: SIMULATION.%.log)',metavar='FORMAT')
parser.add_option('-l','--lines',dest='lineList',help='Lines of TABLE to use, in the format 2,3-5,8,11-13 (default: all available lines in TABLE)',metavar='LIST')
parser.add_option('--nice',dest='nice',type='int',help='Nice value of spawned jobs (default: 10)',default=10)
parser.add_option('--executable',dest='executable',help='Name of the program to run (default: %s)'%sys.argv[0][:-6],default=sys.argv[0][:-6],metavar='FILE') ## strip the '-multi' extension
opts,args=parser.parse_args()
logFormat,lineList,maxJobs,nice,executable=opts.logFormat,opts.lineList,opts.maxJobs,opts.nice,opts.executable

if len(args)!=2:
	#print "Exactly two non-option arguments must be specified -- parameter table and script to be run.\n"
	parser.print_help()
	sys.exit(1)
table,simul=args[0:2]
if not logFormat: logFormat=(simul[:-3] if simul[-3:]=='.py' else simul)+".%.log"
if (not '%' in logFormat) and ('@' not in logFormat): raise StandardError("Log string must contain at least one of `%', `@'")

print "Will run `%s' on `%s' with nice value %d, output redirected to `%s', %d jobs at a time."%(executable,simul,nice,logFormat,maxJobs)

ll=['']+open(table,'r').readlines()
availableLines=[i for i in range(len(ll)) if not re.match(r'^\s*(#.*)?$',ll[i][:-1]) and i>1]

print "Will use table `%s', with available lines"%(table),', '.join([str(i) for i in availableLines])+'.'

if lineList:
	useLines=[]
	def numRange2List(s):
		ret=[]
		for l in s.split(','):
			if "-" in l: ret+=range(*[int(s) for s in l.split('-')]); ret+=[ret[-1]+1]
			else: ret+=[int(l)]
		return ret
	useLines0=numRange2List(lineList)
	for l in useLines0:
		if l not in availableLines: print "WARNING: skipping unavailable line %d that was requested from the command line."%l
		elif l==1: print "WARNING: skipping line 1 that should contain variable labels"
		else: useLines+=[l]
else: useLines=availableLines
print "Will use lines ",', '.join([str(i) for i in useLines])+'.'
# find column where description is
try:
	idColumn=ll[1].split().index('description')
	idStrings={}
	for i in useLines: idStrings[i]=ll[i].split()[idColumn] # textual descripion of respective lines 
	print idStrings
except ValueError:
	idColumn=None
	idStrings=None


jobs=[]
for i,l in enumerate(useLines):
	logFile=logFormat.replace('%',str(l))
	if idStrings: logFile=logFile.replace('@',idStrings[l])
	jobs.append(JobInfo(i,idStrings[l] if idStrings else '#'+str(i),'PARAM_TABLE=%s:%d nice -n %d %s -N PythonUI -- -n -x %s > %s 2>&1'%(table,l,nice,executable,simul,logFile),logFile))

print "Job summary:"
for job in jobs:
	print '   #%d (%s):'%(job.num,job.id),job.command
# OK, go now
concurrent_batches([job.command for job in jobs],maxjobs=maxJobs)
print 'All jobs finished, bye.'
