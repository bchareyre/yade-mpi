\documentclass[times, 12pt]{report}

\usepackage{latex8}
\usepackage[dvips]{graphicx}
\usepackage[dvips]{color}
\usepackage{amsmath}
\usepackage[T1]{fontenc}
\usepackage{algorithmic}

\pagestyle{empty}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{titlepage}

\vspace{\stretch{2}}
\vspace{\stretch{1}}

\begin{center}
    \today
\end{center}

\vspace{\stretch{2}}
\vspace{\stretch{1}}

\begin{center}
    \hrule\smallskip\hrule\medskip\medskip
    {\Huge \bold{YADE} \\}
    {\small \bold{Y}et \bold{A}nother \bold{D}ynamic \bold{E}ngine \\}
    \medskip\medskip\medskip\medskip
    {\Large User Manual v0.5}
    \medskip\hrule\smallskip\hrule
\end{center}

\vspace{\stretch{2}}

\begin{center}
    \Large\medskip\medskip
    \begin{tabular}{rcl}
        Autor		& : & Olivier Galizzi		\\
	email		& : & olivier.galizzi@imag.fr	\\
        Laboratories	& : & L3S and GRAVIR		\\
    \end{tabular}
\end{center}

\vspace{\stretch{3}}

\begin{center}

\begin{tabular}{cccc}
%    \includegraphics[width=3cm]{logoCNRS.eps} &
%    \includegraphics[width=3cm]{logoINPG.eps} &
%    \includegraphics[width=3cm]{logoINRIA.eps} &
%    \includegraphics[width=3cm]{logoUJF.eps}
\end{tabular}

\vspace{\stretch{3}}

\medskip
\hrule \smallskip
    {\scriptsize GRAVIR / IMAG - INRIA Rhône-Alpes - ZIRST - 655 avenue de l'Europe - 38330 Montbonnot Saint-Martin - France}       \\
     {\scriptsize Téléphone : +33 4 76 61 54 26 - Télécopie : +33 4 76 61 54 40 - Adresse internet \emph{http:\bs\bs www-evasion.imag.fr} } \smallskip \\
 \smallskip \hrule

\end{center}

\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\pagestyle{plain}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction to Yade}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\section{What is Yade ?}

	YADE is a simulation framework composed by one main software, libraries and plugins that helps the developper to implement new algorithms linked to a simulation proccess (i.e. collision detection, constitutive law etc). For now, it is well suited for 3D lagrangians simulations, as rigid-bodies simulations, discrete elements simulations, smooth particle hydrodynamic systems, mass spring systems, finite element simulations and so on. We do not plan to add support for 2D simulations and eulerian simulations (like usual fluid simulation) since their requirement are not compatible with the current framework underlyings. Yade is an open source software based on the GPL license. It is available for Unix/Linux system and we hope soon for Windows.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	\section{Why Yade ?}

	The purpose of YADE is to provide a common framework for all user, that allows them to speak the same "language", to reduce the lines of code to write and to increase compatibility between different simulation algorithms. This last point  may be interresting to have a coupling between different models. Such a framework also facilitate comparison between different algorithm (speed, stability, memory usage etc). To achieve that goal we need a common and fixed central core that will be used by everybody. Developpers only have to create plugins that are loaded by this central core.  So nobody will never have to modify this core. This is basic requirement to have a common platform. The framework is also designed to increase reusability of code : math library, computationnal geometry library and several others are provided into separate packages. They can be used without YADE if needed. But the main purpose of them is to gather thos most used algorithms as quaternion or matrixes implementation, distances or intersections computation and many other computationnal geometry algorithms. All these kind of algorithms are oftently well known by the community but they are all spread everywhere and a lot of time has to be spent to find them on the internet or papers and then to adapt them to particular data types or code structure. Reusability is also increased through the plugins : a plugin can be build on top of another one and you can use different combination of plugins to achieve the same goal without recompiling nor modifying existing one.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\section{How is designed Yade ?}
	
	\subsection{Reusability and extensibility}
	
	So the two main caracteristics of YADE to remember are reusability and extensibility. Everything was implemented in that way. The plugins are the key to those two criterions. They allow developpers to add new functionnalities without recompiling everything and so they allow them to focus on their particular problems : if you want to add a new collision dectection algorithm no need to understand how dynamics works and vice versa ! Of course, each plugin can be compiled independently. The developper will always deal with small pieces of code that are easy to compile and easy to maintain. Of course dependencies can be created between plugins if, for example, you want to reuse another plugin to create your own one. 


	\subsection{Philosophy and internal structure}

	The bet taken into YADE is to say that almost all lagrangian discrete simulation can be reduced to objects (the one we want to simulate) that are called \emph{\bold{bodies}} into the framework and \emph{\bold{interactions}} between those bodies. Most of the time, interactions between bodies has to be detected and a model of the interaction is then created. Finally responses are computed for each interactions. Those responses are called \emph{\bold{physical action}} into the framework (the physical action can be a force which will be applied in response to a contact in a force/displacement method). Applying those responses to the bodies will modify some variable of the bodies in such a way that after taking the time into account, they are in a new state at the next time step. All the algorithms that perform the detection of the interactions, the computation of the responses, the application of the responses and the time integration are called here \emph{\bold{engines}}.
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Requirement}

	Here is described what you should know to feel at ease when developping plugins for yade.
	

\section{C++}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\


\begin{itemize}
	\item tatic cast and dynamic cast
	\item Standard template library (STL) (vector,list,map no float[])
	\item Boost library (shared\_ptr no float*)
	\item Singleton pattern
	\item Plugins and dynamic library
\end{itemize}

\section{Software engineering}

//				\\
//				\\
// TODO ..........		\\
//				\\
//

\begin{itemize}
	\item Object programming paradigm
	\begin{itemize}	
		\item class inheritance
		\item polymorphism 
	\end{itemize}		
	\item Singleton pattern
\end{itemize}

\section{Tips and tricks}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

\begin{itemize}
	\item static\_cast<**>shared\_ptr.get() to fast access a polymorphic shared\_ptr (50 times faster than dynamic\_pointer\_cast !!)
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Get ready}

\section{Yade packaging and naming system}

Yade is splitted into several packages :
	\begin{itemize}
		\item \bold{yade-core}	: this package contains the core of YADE. All abstract classes that needs to be specified into plugins to make something with this core are here. All the data structure to store the object you want to simulate ... are also defined here.
		\item \bold{yade-lib-*}: to compile yade-core you will have to compile first those libraries because they are all used by YADE. 
			\begin{itemize}
				\item \bold{yade-lib-gui-*}
				\item \bold{yade-lib-serialization-*}
			\end{itemize}
				
		\item \bold{yade-common}	: this package contains most common implementation of abstract classes defined into yade-core. It laso has to be installed because others packages are based on it.
		\item \bold{yade-packages-*}	: For each type of simulation a package is defined. For example you have yade-package-fem, yade-package-dem ... Each of them contains implementations of abstract classes defined into yade-core related to a specific field. Most of the time they contain all plugins used to perform dem or fem ... simulation. So if you do only DEM simulation, no needs to install the FEM package.
	\end{itemize}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\
	
	
\section{Where and how to download Yade}

Berlios web site : http://yade.berlios.de

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\


\section{How to install Yade}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Yade internal structure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Global architecture}

	The main issue when developping a simulation framework is to find the good trade off between enough genericity and strong concepts that guide the developpers and structure the simulations code while keeping them compatible. Basically, too much genericity generally leads to something too abstract were everything tends to fit into. It also leads to a slower code. This is useless. It is better to develop your own code ! On the contrary too strong concepts will limit too much what it is possible to do with the framework in term of diversity of simulation. The solution implemented into Yade to address this issue is a double layered structure (see \figref{fig:doublelayer}):

\begin{itemize}
	\item The first layer is quite generic. It is implemented into the core of Yade mentionned in previous chapter.
	\item The second layer is built on the top of the first one and is dedicated to a specific field.
\end{itemize}

\epsfigure{19cm}{images/doublelayer.eps}{Double layered architecture of Yade.}{fig:doublelayer}

We hope that we have found with this structure a good balance between genericity and efficienty as well as between fexibility and something too embedded.

\paragraph{}	
	Each package that belongs to the specialized layer is composed by many plugins that will be plugged onto the core and comes with its own specificities. For example the discrete element package define collision detection engines for rigidbodies, the constitutive law to apply at each contact, the parameters that define a rigid body (mass, intertia, young modulus etc) and so on. This aggregation of plugins into packages has been choosen to simplify the global vision of Yade. As the number of plugins grows it become more and more difficult to know easily which one is dedicated to such or such task especially if they are all stored into one place. On top of that packaging and in order to simplify the developpement of new packages an intermediate one is available. It is called \emph{yade common} and contains some basic plugins not specific to a particular field, and which can be reused by others packages. The \figref{fig:archigenerale} shows a more precise vision of the architecture of Yade. In term of different types of elements, we can consider a total of four layers. The specialized layer is build on top of libraries that are the roots of the whome system. The core is working on top or together with those packages. Of course a \bold{G}raphical \bold{U}ser \bold{I}nterface (GUI) is needed to let the user talk with the core and have feedback from it.

\epsfigure{19cm}{images/archigenerale.eps}{Global architecture of Yade.}{fig:archigenerale}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{The first layer}

\subsection{Global structure}


	This layer contains all the abstract classes and common concepts that will be used further by plugins. It contains 3 main modules. The main program, the Omega singleton and the class factory singleton as described by \figref{fig:mainmodules} : 
	
	\begin{itemize}
		\item The main program is just in charge of launching the GUI. The singletons are also constructed when this program starts.
		\item The factory singleton holds a database about all the available plugins and other dynamic libraries. Dynamic libraries stored on the hard drive are all scanned when yade is launched, so you never have to take care of loading a plugin when you need it. Just ask the factory singleton to create an instance for you (you can find information about the class factory further). But anyway when you ask for a plugin, either it is already in memory then an instance is created, otherwise the plugin is loaded from hard drive, but in any case it is transparent for the user. If you are developping plugins you do not have to care about this factory, just use it and this will go fine.
		\item The Omega singleton holds all the data that you need to make your simulation, as the current iteration, various information about the time and time step. It also contains what we have called the \emph{root body} which holds informations about the simulated bodies, the current interactions between them , the simulation loop and some others informations described later (explanation about rootbody can be found in next section). A independent thread is in charge of calling iteratively the simulation loop contained into this root body. Finally a thread synchronizer is needed to synchronize the calls to the simulation loop and to others threads as the 3D display of the bodies for example. If you just want to develop plugins you don't have to care about the threads synchronization.
	\end{itemize}
	
	
\epsfigure{19cm}{images/main_modules.eps}{Main modules.}{fig:mainmodules}


\subsection{The rootbody}

	We can now go deeper in the details with the structure of the root body. As said in the introduction, the philosophy of yade is to deal with objects in interaction that need a response to be applied onto them, to go to a new state after taking the time factor into account. 
	
\paragraph{}
	So in this framework how and where is stored the simulation itself ? This means the bodies, the interactions, the simulation loop, the responses and so on. Here comes the concept of \emph{metabody}. Into Yade you have two kind of bodies : 
	
	\begin{itemize}
		\item "simple" bodies (we will call them bodies in the future by opposition of metabodies) which can be one discrete element, one particle, one tetrahedron. Such a body can't do anything by itself, neither move nor interact with others bodies. It just store information related to its state, geometry etc.
		\item metabodies are a collection of bodies including metabodies, with the capacity of interacting and moving over the time. So the rootbody is a metabody which is at the top the the tree defined by all the bodies and metabodies that participates into the simulation. So it can be according to what you want to simulate :
		\begin{itemize}
			\item a finite element beam
			\item a rigid bodies crumbling 
			\item an piece of cloth that interact with discrete element
		\end{itemize}
		
		It is made of several bodies in interaction, that's why it is of type MetaBody. As you can see in \figref{fig:hierarchy}, a metaBody can be composed by bodies and/or others metabodies. The root of the tree called the rootbody is stored into Omega. In the given example the rootbody is composed by two metabody. The first one is a discrete element simulation and is made of rigid spheres (which are simple bodies) and the second one is a mass spring system made of particles. In this example the rootbody will take care of the interaction between the cloth and the sphere set, whereas the two others metabodies will only take care of their own sub bodies and the interaction between them. This is a way of having a hierarchical simulation and reuse modules to make them work together with a new one. Of course you don't have to use this tree structure. If you just want to run a rigid body simulation you can use a flat structure : a rootbody with all the rigidbodies just under it.
	\end{itemize}

\epsfigure{19cm}{images/hierarchy.eps}{Hierarchy.}{fig:hierarchy}

Let's see now, the full structure of a metabody to understand how it store all the needed information and how it can "compute". As shown in \figref{fig:metabody} a metabody is composed by different types of elements :

	\begin{itemize}
		\item Data		: all data classes are passive. They are classes that only contains information (and almost no method).  For example the properties of a rigid body (mass,inertia,geometry....). We can subdivide data classes into three as said previously :
			\begin{itemize}
				\item Body
				\item Interaction
				\item PhysicalAction
			\end{itemize}
		\item Containers		:  Containers are standard database were all the data classes are stored. They provide basic database interace such as insertion, deletion, research of an element. Because we have three type of data we also have three type of containers :
			\begin{itemize}
				\item A container to store the bodies called BodyContainer 
				\item A container to store the interactions called InteractionContainer
				\item A container to store the physical actions called PhysicalPhysicalAction
			\end{itemize}
		Each container has its own specificities acording to the type of data it stores.
		\item Engines		: Engine classes active classes, which means that they are the classes that "compute". An engine reads and/or procude some data from or to containers. Usually they contain almost only methods and some parameters. Collision detection, damping application,  recording data to hard drive, computing forces in response to collision are all operations performed by engines. A particular list of engines called only once are called initializers. They are used to perform operation that has to be made only once. All the other engines compose together the simulation loop.
	\end{itemize}

\epsfigure{19cm}{images/MetaBody.eps}{Structure of a metaBody.}{fig:metabody}

\paragraph{}
	What is importent to remember here is the separation of methods (stored into engine classes) and information (stored into data classes ) which is a recurent pattern into Yade. It allows the user to define multiple different methods for one type of data class into different engines without either modifying neither recompiling the data class. This imply that you don't have to edit the code of the data class to make new engines. Doing that way allow the data class to remain the same for everybody which ensures compatibility and using such or such engine to act on this class provides different behavior which ensure reusability. Everybody can use and share the same data class and is able to define his own personnal methods that act on that class without the source code of it. This point is described more in details in section about \emph{multimethods}. Basically information is stored into one plugin, and then others plugins define the methods of that data class then an automatic mechanism is here to call the right engine on the right type of data. This process of externalisation of methods outside of the classes is really powerfull. For example let's consider a class Sphere that contains only a radius and a center. Then everyone can define his onwn method to draw the sphere, his own method to do collision detection between two spheres. As a result, the final user will be able to choose between such or such engine according to its needs (performance, accuracy etc).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Data classes}

	The first type of classes we are going to explain is data classes. As already said the data classes only hold information but almost no methods, no algorithms ... This a basic rule to respect because most of the methods will be defined outside the data classes. Let's develop again the example with the sphere (radius+center). Image you write the draw method inside the sphere class. If somebody else thinks your drawing method is not good enough, too slow or simply not adapted to his own case and decide to rewrite it, both classes will no more be the same : your code may not work anymore with the new draw method ; this class can no more be shared among the users. Two versions of the class sphere will exist and each time a new user needs it, he will have to choose between one of them and his code will not be compatible with either your or the other code.
	
	
\subsection{Body}

	In this section we will describe what is a "simple" body only, since the metabody class is already explained in previous section. A body contains five properties that entirely defined it :
	\begin{itemize}
		\item a GeometricalModel
		\item an InteractingGeometry
		\item a BoundingVolume
		\item a State
		\item PhyisicalParameters
	\end{itemize}
	
	Actually there are only four : State and PhysicalParameters are still merged but we plan soon to split them into two. Those properties are described more in details in the following paragraphes. Each properties corerspond to an abstract class store in the core and has to be specified by inheriting them to be usefull.
	
	
\subsubsection{GeometricalModel}

	The \emph{GeometricalModel} of a body is simply its shape. It can be a sphere, a tetrahedron, a box, a polyhedron, a point cloud, a mesh or whatever you want as soon as it is something geometric. From the simulation point of view, it is the best modelisation you can have of the corresponding real life object you want to simulate. For now, the \emph{GeometricalModel} is mainly used to for display. It is also important in the way that InteractingGeometry is build on top of it.

\paragraph{}
	Both body and metaBody can have a geometricalModel. In a case of a piece of cloth, the metabody is composed of bodies which are particles. Its geometry can be a 2D mesh defined on top of the particles, by using a particular connectivity.
	
\subsubsection{InteractingGeometry}

	This is the actual geometry through which the objects interacts with other objects. It is very usefull to make a distinction between the \emph{geometricalModel} and the \emph{interactingGeometry} because your \emph{geometricalModel} may be too complex to handle interaction detection. For example in a rigidbodies simulation your objects may be arbitrary polyhedrons. This is nice and pretty accurate, but it may be extremely difficult to perform collision detection between such polyhedrons. The solution is to use the polyhedron as a \emph{geometricalModel} which is good enough for display and then to fill it with spheres. This union of spheres will be stored as the \emph{interactingGeometry} of your body and can be used collision detection, since it is easy to detect collision between spheres. The second interesting point is that you can build another \emph{interactingGeometry} on top of  your polyhedral geometry and compare it with the sphere union, in term of accuracy, speed and final behavior of your simulations (see \figref{fig:geometry}). Of course if one day you know how to make collision detection between two arbitrary polyhedrons you can use the polyhedral model for both  \emph{geometricalModel} and \emph{interactingGeometry}. This often appends : for example if the \emph{geometricalModel} is a sphere then they are no simpler model than the sphere to make collision detection, so the spherical model will also be used as \emph{interactingGeometry}.

\subsubsection{BoundingVolume}

	In general to speed up collision detection or more generaly interaction detection, it has to be defined a \emph{bounding volume} around the geometry of the object. A bounding volume is a very simple shape that surround the geometry and fits it as better as possible. This volume is then used to perform a preliminary test to check for the possibility of interaction of the two underliyng geometries. If this test fails then there is no possibility of interaction between the two objects, but if it succeeds then there may be an interaction and the \emph{interactionGeometry} will be checked. Of course the better the bounding volume fits the geometry the more accurate this check is, but as usual the longer it takes to perform.

\epsfigure{14cm}{images/geometry.eps}{Geometry.}{fig:geometry}


\paragraph{}
	The good point here is that it is possible to define different \emph{geometricalModel}, \emph{interactingGeometry} and \emph{boundingVolume} and test different combinations to see which one suits the most your application in term of performances or memory usage. Of course the union of sphere can be reused with different geometrical model such as a box or an implicite surface as long as you know how to build it from such a model.
	
	
	
\subsubsection{State}

	This is simply the state of your body. For a rigid body it is the position and orientation as well as the velocity and the angular velocity. For a particle it is only the position and velocity. Because we are in a dynamic framework informations stored here should vary along with the time according ti time integration, because the objects move, accelerate.

\subsubsection{PhysicalParameters}

	This property correspond to the remaining information about a body that is not related to any geometrical informations or information about the state of the body. For a rigid body it can contain the mass, the inertia matrix, the young modulus and the poisson's ratio. For a finite element it can contain the stiffness matrix and the mass. Usually the informations stored here are not variable.

\subsubsection{Conclusion on body}

To sum up, in Yade core you will find six abstract classes that fully define what is a body :
\begin{itemize}
	\item \emph{Body}
	\item \emph{geometricalModel}
	\item \emph{interactingGeometry}
	\item \emph{BoundingVolume}
	\item \emph{State}
	\item \emph{PhysicalParameters}
\end{itemize}

You shoud not have to inherits the class Body to define you own body but is there are no other choices. By choosing one combination of the five remaining classes you create one type of body. The \figref{fig:bodyexample} shows an example that define a rigid body with a polyhedral geometry, a union of sphere as interacting geometry and an axis aligned bounding box as bounding volume.

\epsfigure{19cm}{images/bodyexample.eps}{Example of body. Here is defined a rigid body.}{fig:bodyexample}



They are a lot a possible dispatcher according to the number of different data we are using. Because a dispatcher is identified by the dispatched type and the returned type.
Currently we use 8 type of data :
	\begin{itemize}
		\item BoundingVolume
		\item InteractingGeometry
		\item GeometricalModel
		\item State
		\item PhysicalParameters
		\item NarrowInteractionGeometry
		\item InteractionPhysics
		\item PhysicalAction
	\end{itemize}
	
	
\subsection{Interactions}

	They are mainly two types of interactions :
	\begin{itemize}
		\item interactions that appears due to spatial proximity and that disappear by themselve when spatial proximity no longer exists. This kind of interaction is called \emph{volatileInteraction} into Yade framework. For example a collsion between two rigib bodies is one type of \emph{volatileInteraction}.
		\item By opposition of \emph{volatileInteraction} there are \emph{persistentInteraction} that are defined manually into configuration file most of the time but they also can occur during runtime. They are not disappearring by themselve as with \emph{volatileInteraction} but somebody has to define an arbitrary criterion that, when reached will cause the destruction or modification of \emph{persistentInteraction}. For example you may want to create some cohesive links between between rigid bodies, that will be created when the configuration file is loaded. Those links will be destroyed when an arbitrary strengh criterion is reached. You may also want to glue two bodies when they collide : this glue will not disappear when the collision no longer exists but when a specific criterion is overcome as for example a distance threshold. In both cases, the type of the interaction is persistent interaction because the interaction does not disappear spontaneously but according to a criterion that the user has defined.
	\end{itemize}
	
	\paragraph{}
	The only difference between them is that they are store in two different containers so you can access them more quickly. Both of them are composed of the two following properties : 
	\begin{itemize}
		\item an interaction geometry
		\item an interaction physics
	\end{itemize}
	
They are as describe more in details in next sections. 
	
\subsubsection{InteractionGeometry}

	This is a snapshot of the geometry of the contact at current time step. This property is build by taking into account the \emph{interactingGeometry} of two (if you are dealing with binary interaction such as contact) or more bodies. It should contain enough information so that a after its detection and modelisation, there is no need to access again the interacting geometry of the corresponding bodies to make any further computation or to access more information. The \figref{fig:interactionGeometry} shows two examples of interaction geometry.
	
	\epsfigure{19cm}{images/interactionGeometry.eps}{Two examples of interaction geometry.}{fig:interactionGeometry}

\paragraph{}
	 Of course once is defined a new type of \emph{interactionGeometry}, the corresponding engine(s) which will construct this property if an interaction is found between two bodies have to be defined ! The fewer information you need to build the \emph{interactionGeometry} the more reusable will be this class and also the engines that come with it. It is quite important because usually the engines in charge of detecting and modelising interactions such as contact can be quite complex. So if they can be reused by many simulations it is much better. 
	

\paragraph{Caution :} Be careful to not confuse between the \emph{interactingGeometry} of a body which is the actual geometry through which the body interacts and the \emph{interactionGeometry} which is the geometry of an interaction.


\subsubsection{InteractionPhysics}

	This contain all the physical parameters of the interaction which are not especially related to some geometric information. For example you may need to compute the normal and shearing stiffness at a contact between two objects from their young modulus and poisson's ratio. These stiffnesses will be used as long as the contact remains and they should be stored into a specific interactionPhysics class maybe aside with other properties.
	
\paragraph{}
	
	 This property can be much more specific than the \emph{interactionGeometry} because it is usually easier to build. Let's take an example. In some discrete element simulation, the previous normal at the contact point is required to compute the shearing force. This previous normal has to be stored into the \emph{InteractionPhysics} property even if it is seems to be related to some geometrical information and so stored into the \emph{interactionGeometry} property. The point is that this normal is really specific to a particular method so if it is stored into the \emph{interactionGeometry} of the contact then in every simulation method that do not need it, this attribute will be defined and not used : so both memory and CPU usage will be waste to store and compute it.

\subsubsection{Conclusion on interaction}

	An interaction is made of two properties : 
	\begin{itemize}
		\item an interaction geometry
		\item an interaction physics
	\end{itemize}

	This means in the core of Yade you will find three abstract classes :
	\begin{itemize}
		\item \emph{Interaction}
		\item \emph{InteractionGeometry}
		\item \emph{InteractionPhysics}
	\end{itemize}
	
	To define your own Interaction you have to overload both \emph{InteractionGeometry} and \emph{InteractionPhysics}. Of course it would have been possible to use here only one property which is the merge between the geometry and the physicals parameters of the interaction. But to increase reusability of code it has been choosen to split them. Of course it is up to you to think of what should be inside the geometry and inside the physical parameters !

\subsection{PhysicalAction}

	A physical action is everything that can be applied to a body to modify its state usually in response to some interaction. For a rigidbody, it can be :
	\begin{itemize}
		\item a force $[kg m/s^2]$
		\item an acceleration $[m/s^2]$
		\item an impulse $[kg m/s]$
		\item a displacement $[\Delta m]$
		\item a velocity $[m/s]$
		\item a momentum $[kg m^2/s^2]$
		\item or a combination of them.
	\end{itemize}
	
//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

\subsection{Conclusion on data classes}

Currently 8 types of abstract data classes are defined into Yade :

	\begin{itemize}
		\item BoundingVolume
		\item InteractingGeometry
		\item GeometricalModel
		\item State
		\item PhysicalParameters
		\item NarrowInteractionGeometry
		\item InteractionPhysics
		\item PhysicalAction
	\end{itemize}	

By inheriting them you can define your own bodies, interactions and physical action.
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
\section{Containers}

	For each type of data we need a way to store them. That's why three types of containers are defined : 
	\begin{itemize}
		\item a container that stores the bodies
		\item a container that stores the interactions
		\item a container that stores the physical actions
	\end{itemize}
	
	\paragraph{}
	We have choosen to encapsulate the containers in which the data classes are stored so that it is possible to define several one. One will be made with chain list and will have fast insertion, an other will be made with vector and will have fast access etc. The big advantage, is that, depending of your application, you will be able to privilege such or such property of your containers. For example if you know that you are not going to add or remove bodies on runtime, there is no need to use a container that is able to preserve the ids of the bodies (which are used to identify them into the interaction for example). If you know that you are dealing only with binary interactions, then you may implement an optimized container that is able to store only binary interactions.
	The counterpart is, as always, by adding one level of abstraction we may loose some performances in term of speed of access, insertion but we think the is negligible compared to the benefits.

	\paragraph{}
	Of course, it is up to you to choose the one which is the best suited for your particular application. You may want fast insertion or fast access and this affect the type of the container used. Most of the containers will be stored into yade common package because there are highly reusable.

\subsection{BodyContainer}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

\subsection{InteractionContainer}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

\subsection{PhysicalActionContainer}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

%just find no insert 
%usefull to store responses to collision if we need access to them for example to have access to sum of forces on one body.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Engines}

	Engines read and/or produce  some data from/to containers. Some engines are modifying or reading data, some others a creating data, some others can delete data.
	For now engines only perform thoses basic operations but we plan to make engine that are able to do complex operations such as splitting bodies, merging bodies, transforming a body into another. The engines are stored into two places :
	\begin{itemize}
		\item in the simulation loop
		\item in the initializer list
	\end{itemize}
	
Those placed into the initializers list are called once when a new configuration file is loaded. For example they can compute the bounding volume of the bodies from their interacting geometry. Those placed into the simulation loop are called one after each other in loop until the simulation ends. Here can be find engines that detect collision, compute responses to collision and so on.

\paragraph{}
	Here are some common concrete example. A engine can :
	\begin{itemize}
		\item access data from \emph{BodyContainer} and use the \emph{BoundingVolume} property of the bodies to find all potential pair of interacting bodies
		\item read data from \emph{BodyContainer} and \emph{InteractionContainer} and use the \emph{InteractingGeometry} property as well as all the potential collision to modelise the \emph{InteractionGeometry} of collision that really occur.
		\item produce \emph{GeometricalModel} for bodies. For example create a Polyhedron from WRML file.
		\item access all the forces stored into \emph{PhysicalActionContainer} and update data to BodyContainer by applying those forces to rigid bodies.
		\item updates all forces stored into \emph{PhysicalActionContainer} by applying some damping
		\item access the collisions stored into  \emph{volatileInteractionContainer}, then compute a forces in response to those collision and finally store those forces into \emph{PhysicalActionContainer}
		\item read data from one of the containers to write them down on the hard drive
	\end{itemize}

All engines classes are serializable, because an engine often uses parameters that you may want to tune yourself in the configuration file. Different type of engines can be found into Yade :
	\begin{itemize}
		\item stand alone engines
		\item Meta engine which are engine composed of engine 
		\item engine unit which is a part of an meta engines
		\item DeusExMachina engine 
	\end{itemize}

	
\subsection{Stand alone engines}

	A stand alone engine inherits only from the Engine class. It performs a unique operation : for example, it computes the appropriate time step, it computes the forces to apply the bodies in response to a collision.
	
	
	\code
	{
		\> \>	\class Engine : \kw{public} Serializable				\\
		\> \>	\{									\\
		\> \> \>	\pub : Engine() \{\};						\\
		\> \> \>	\pub : \virtual ~Engine() \{\};					\\
												\\
		\> \> \>	\pub : \virtual \bool isActivated() \{ \return \true; \};	\\
		\> \> \>	\pub : \virtual \void action(Body*) \{ throw; \};		\\
		\> \> \>	\pro : \virtual \void postProcessAttributes(\bool d) \{\};	\\
		\> \> \>	\pub : \virtual \void registerAttributes() \{\};		\\
												\\
		\> \> \>	REGISTER\_CLASS\_NAME(Engine);					\\
		\> \>	\};									\\
		\> \>	REGISTER\_SERIALIZABLE(Engine,\false);					
	}			
		
	Putting aside the usual line linked to serialization of class factory, the two important remaining methods are :


	\code
	{
		\> \virtual \bool isActivated();	\\
		\> \virtual \void action(Body*);
	}
	
	In the simulation loop the calls to engines are made in two time. First a call is made to \emph{isActivated} to know if the engine is active or not. By default this function return \emph{true} so if it is not overloaded (which is the case most of the time, the engine is always considered as active. You can define in this method your own criterion of activity. For example if you want to check for new contact each 10 iteration you just have to write :
	
	\code
	{
		\>	\bool myEngine::isActivated()						\\
		\>	\{									\\
		\> \>		\return (Omega::instance().getCurrentIteration()\%10==0);	\\
		\>	\}
	}	
	
	If and only if and engine is active the method action is called. The parameter \emph{Body} is usually a MetaBody that contains all the information you may need to make any task : collision detection, responses computation ... 
	
\subsection{MetaEngine and EngineUnit}

	A meta engine is an engine made of engines. It usually inherits from both the Engine class and the DynlibDispatcher class from multimethod library. This kind of engine is used to perform specialised operation on particular type of data. As previously said, they usually highly use the multimethod library which allows dispatching.
They are very usefull to handle the method of the data classes as we will see.	For now there ara mainly two types of  meta engines. One dimensionnal meta engine and two dimensionnal meta engine. Both of them are composed by EngineUnit that inherits from FunctorWrapper class. Basically, according to the type of data they work with, a meta engine will call the correct Engine unit. So first, when a metaengine is defined, the abstract class for all the engine unit has also to be defined. One metaengine works with one type of engine unit.

\paragraph{}
	One dimensionnal meta engines are mainly used to externalize virtual method of one of the data classes. You just have to specify which type of engine unit to use on which type of data then when the metaengine is looping over the data classes it is dealing with, the correct engine units are automatically called. For example you can externalize the draw method out of the geometricalModel. Then you define a 1d metaengine that works with one engine unit that take one \emph{geometricalModel} as parameter and define how to draw it. If you are dealing with tetrahedrons and cubes you have to make 2 engine units. One will know how to draw a tetrahedron, the other how to draw a cube. The metaengine will then call the correct engine unit when  you will ask to draw a sphere or a cube. This is illustrated by \figref{fig:1dmetaengine}.

\epsfigure{19cm}{images/1DMetaEngine.eps}{1DMetaEngine.}{fig:1dmetaengine}

\paragraph{}
	Two dimensionnal meta engines are the same as one dimensionnal but they dispatch on two types of data. This is the most interresting type of meta engine. The \figref{fig:2dmetaengine} shows an meta engine that knows which engine unit to call when you ask for collision detection between a sphere and a cube or 2 spheres.

\epsfigure{11cm}{images/2DMetaEngine.eps}{2DMetaEngine.}{fig:2dmetaengine}


\subsection{DeusExMachina}
	
	It is a stand alone engine which contain a list of subscribed bodies. For each subscribed body it applies a particular movement or condition according to an arbitrary law defined by the user. It can be used to apply border condition to apply gravity to all bodies and so on.
	
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
\chapter{The libraries}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Serialization}

	Serialization is the process of taking an object and converting it to a format in which it can be transported across a network or persisted to a storage location (ie hard drive disk). The storage location could be as simple as using a file or a database. The serialized format contains the object's state information. Deserialization is the process of using the serialized state information to reconstruct the object from the serialized state to its original state. In essence, the process of serialization allows an object to be serialized, shipped across the network for remoting or persisted in a storage location such as an XML file, and then be reconstructed for use at a later point in time. 
	Through the library yade-lib-serialization, Yade propose an easy way for serializing objects to a C++ stream.  This stream can be a file on the disk, a chunk of memory or a network stream. For now the format used to save and restore the state of  a class is XML. But it is possible to define new format, as binary, YAML and so on without modifying or recompiling the  yade-lib-serialization library. This is a very powerfull capacity, since you can define your own format with minimal work to do according to what your needs : a compact format, a more descriptive one ...

	On top of that we provide a very easy way to make an object serializable. Let's consider the class A defined as follow :
	
		\code
		{
			\> \> \class  A					\\
			\> \> \{					\\
			\> \> \> \pri : \integer i;			\\
			\> \> \> \pro : \float f1, f2, average;		\\
			\> \> \> \pub : \kw{Vector3} v;			\\
			\> \> \}					
		}
		
	To make it serializable you just have to add the following lines : 

		\code
		{
				\> (1)	\>	\inc <yade-lib-serialization/Serializable.hpp>			\\
														\\
				\> (2)	\>	\class A : \kw{public} Serializable				\\
				\>	\>	\{								\\
				\>	\>\>		\pri : \integer i; 					\\
				\>	\>\>		\pro : \float f1, f2, average;				\\
				\>	\>\>		\pub : \kw{Vector3} v;					\\
														\\
				\> (3)	\>\>		\pub : \void registerAttributes();			\\
				\> (4)	\>\>		\pro : \virtual \void postProcessAttributes(\bool d);	\\
				\> (5)	\>\>		\pro : \virtual \void preProcessAttributes(\bool d);	\\
														\\      
				\> (6)	\>\>		REGISTER\_CLASS\_NAME(A);				\\			       
					\>\>	\}								\\
														\\
				\> (7)	\>\>       REGISTER\_SERIALIZABLE(A,\false); 								       
		}

	Line (1) is needed to include the class Serializable which is the basic interface to all serializable classes. That's why on line (2) you have to make tour class inheriting the Serializable one.
	On line (3) is defined the registerAttributes function which you have to overload. With this example you will have : 
	
	\code
	{
	   \> \>	\void A::registerAttributes()	   \\
	   \> \>	\{				   \\
	   \> \> \>		REGISTER\_ATTRIBUTE(i);	   \\
	   \> \> \>		REGISTER\_ATTRIBUTE(f1);   \\
	   \> \> \>		REGISTER\_ATTRIBUTE(f2);   \\
	   \> \> \>		REGISTER\_ATTRIBUTE(v);	   \\
	   \> \>	\}
	}
	
	For explanation about REGISTER\_CLASS\_NAME (line 6) macro see section about class factory.

	By calling the macro REGISTER\_ATTRIBUTE (line 7) you tell the serialization system that you want to serialize such or such attribute.

	Of course if you have a class hierarchy as this one :
	
	\code
	{
		\> \>	\class B : \kw{public} A			\\
		\> \>	\{						\\
		\> \> \>	\pri : \kw{Matrix3} m;			\\
									\\
		\> \> \>	\pub : \void registerAttributes();	\\
		\> \>	\}						\\
									\\
		\> \>	REGISTER\_SERIALIZABLE(B,\false);		\\
	}

	You need to call from the registerAttributes function of B the registerAttributes function of A. If you don't, attributes that comes from A won't be serialized when B is serialized. So it is better to always call the registerAttributes of the mother class so that you are sure that is new attributes are defined in the future into this mother class, they will be taken into account in your own class.

	\code
	{
		\> \>	\void B::registerAttributes()		\\
		\> \>	\{					\\
		\> \> \>	A::registerAttributes();	\\
		\> \> \>	REGISTER\_ATTRIBUTE(m);		\\
		\> \>	\}					
	}
	
	On line (4) and (5) you can overload if you want (but it is not necessary) the postProcessAttributes and preProcessAttributes functions. The preProcessAttributes function is called before the serialization and deserialization of the class. The same is for function postProcessAttributes which is called after serialization and deserialisation. Inside the function you can know if you are in a serializing or deserializing process by checking the boolean value d. If it is true then you are currently deserializing the object, if it is false then you are serializing the object. It may be very usefull for example if you don't need to serialize one attribute because you can compute it from one or more others attributes. In class A you may not want to serialize attribute average because it is just the average between f1 and f2. So to restore A in a correct state after deserialisation you can overload postProcessAttributes as follow : 

	\code
	{
		\> \> 	\void A::postProcessAttributes(\bool d)			\\
		\> \> 	\{							\\
		\> \> \>	if (d) \comment{if we are deserializing A}	\\
		\> \> \> \>		average = (f1+f2)/2;			\\
		\> \>	\}						
	}

	Of course if you are into B it is better to do as follow for the same reason mentionned with the function registerAttributes.
	\code
	{
		\> \> 	\void B::postProcessAttributes(bool d)		\\
		\> \> 	\{						\\
		\> \> \>	A::postProcessAttributes(d);		\\
		\> \>	\}						\\
	}

	Finally you have to register your class to the serialization system by calling the macro REGISTER\_SERIALIZABLE after the definition of your class. This macro takes two parameters. The first one is the name of your class. The second one is not improtant for now and should be false.


	The serializable library can't work alone. You have to define what we have called an IOManager that will be in charge of defining all the specificities to a particular format. That's why it is possible to define your own format, by defining your own IOManager. As said before, for now the only IOManager defined is the XMLManager that serializes object to the XML format. Let's see how to use an IOManager together with the serialization library. First of all you have to put your IOManager into a library. XMLManager is stored into the yade-lib-serialization-xml library.

To deserialize the serializable object A from a stream :

	\code
	{
		\> \> 	A a;											\\
		\> \> 	a.i	\> = 2;				\comment{I know it is private :)}		\\
		\> \> 	a.f1	\> = 3.14.15;									\\
		\> \> 	a.f2	\> = 6.2;									\\
		\> \> 	a.v	\> = Vector3(1,2,3);		\comment{I know it is protected :)}		\\
		\> \> 	\sharedptr{XMLManager} xmlManager(\new XMLManager);					\\
		\> \> 	ofstream fileStream("fileA.xml");							\\
		\> \> 	xmlManager->saveArchive(fileStream,a,"A");						\\
		\> \> 	fileStream.close();									
	}
	
	The result of thoses lines is a file whose name is fileA.xml and which contain the following : 

	\code
	{
		\> \>	<A i="2" f1="3.1415" f2="6.2" v="{1 2 3}" \bs A>
	}

To deserialize the serializable object A from a stream :
		
	\code
	{
		\> \> \sharedptr{XMLManager} xmlManager(new XMLManager);			\\
		\> \> ifstream fileStream("fileA.xml"); \comment{here we choose a file stream}	\\
		\> \> xmlManager->loadArchive(fileStream,A,"A");				\\
		\> \> fileStream.close();							
	}
	
	This loads to the content of file fileA.xml into object A.


	For (de-)serialization to and from files facilities are provided. To serialize an serializable object "s" to a file named "fileName.xml" using the "XMLManager" class  as IOManager, you just have to write : 

	\code
	{
		\> \> IOManager::saveToFile("XMLManager", "fileName.xml","S",s);
	}

To restore the state of object "s" from the same file you just have to write : 

	\code
	{
		\> \> IOManager::loadFromFile("XMLManager","fileName.xml","S",s);
	}


	Of course you can do much complex things if your object hold pointer on others serializable object, or if it contains vector of vector of int ... Any combinations works as long as you use STL standard types. For example :

	\code
	{
		\> \> 	\class Body : \kw{public} Serializable					\\
		\> \>	\{									\\
		\> \> \>	\pub : \sharedptr{PhysicalParameters} physicalParameters;	\\
		\> \> \>	\pub : \sharedptr{GeometricalModel} geometricalModel;		\\
		\> \> \>	\pub : \sharedptr{InteractingGeometry} interactingGeometry;	\\
		\> \> \>	\pub : \sharedptr{BoundingVolume} boundingVolume;		\\
		\> \> \>	\pub : \integer id;						\\
		\> \> \>	\pub : \bool isDynamic;						\\
		\> \>	\}
	}

	\code
	{
		\> \> 	\class Polyhedron : \kw{public} GeometricalModel			\\
		\> \>	\{									\\
		\> \> \>	\pub : \kw{vector}<\kw{Vector3}> vertices;			\\
		\> \> \>	\pub : \kw{vector}<\kw{vector}<\kw{Vector3}> faces;		\\
		\> \> \>	\pub : \kw{Vector3} color;					\\
		\> \> 	\}
	}


	\code
	{
		\> \> 	\class Sphere : \kw{public} InteractingGeometry				\\
		\> \>	\{									\\
		\> \> \>	\pub : \kw{Vector3} center;					\\
		\> \> \>	\pub : \float radius;						\\
		\> \> \>	\pub : \kw{Vector3} color;					\\
		\> \>	\}
	}
	
	\code
	{
		\> \> 	\class AABB : \kw{public} BoundingVolume				\\
		\> \>	\{									\\
		\> \> \>	\pub : \kw{Vector3} center;					\\
		\> \> \>	\pub : \kw{Vector3} extents;					\\
		\> \> \>	\pub : \kw{Vector3} color;					\\
		\> \>	\}
	}
	
	\code
	{
		\> \> 	\class RigidBodyParameters : \kw{public} PhysicalParameters		\\
		\> \>	\{									\\
		\> \> \>	\pub : \kw{Vector3} inertia;					\\
		\> \> \>	\pub : \float mass;						\\
		\> \> \>	\pub : \kw{Vector3} velocity;					\\
		\> \> \>	\pub : \kw{Vector3} angularVelocity;				\\
		\> \> \>	\pub : \kw{Se3} se3;						\\
		\> \>	\}
	}

	Let's now define a body and serialize it into a file:
	
	\code
	{
		\> \> 	Body b;													\\
		\> \> 	b.physicalParameters	\> \> \> \> \> = \sharedptr{PhysicalParameters}(\new RigidBodyParameters);	\\
		\> \> 	b.geometricalModel 	\> \> \> \> \> = \sharedptr{GeometricalModel}(\new Polyhedron);			\\
		\> \> 	b.interactingGeometry	\> \> \> \> \> = \sharedptr{InteractingGeometry}(\new Sphere);			\\
		\> \> 	b.boundingVolume 	\> \> \> \> \> = \sharedptr{BoundingVolume}(\new AABB);				\\
		\> \> 	\comment{}												\\	
		\> \> 	\comment{... of course we need to specify all the values here}						\\
		\> \> 	\comment{}												\\
																\\	
		\> \> 	IOManager::saveToFile("XMLMAnager", "myBody.xml","b",b);
	}

	The result is a file named "myBody.xml" that contains the following :
	
	\code
	{
		\> \> 	<b id="3" isDynamic="1">									\\
		\> \> \>	<physicalParameters \_className\_="RigidBodyParameters" inertia="{2.3 4.9 4.1}" 	\\
		\> \> \> \>		mass="3.23" 									\\
		\> \> \> \>		velocity="{2.4 0 0}" 								\\
		\> \> \> \>		angularVelocity="{0 0 0}" 							\\
		\> \> \> \>		se3="{1 3 2 1 0 0 0}" 								\\
		\> \> \>	\bs physicalParameters>								\\
		\> \> \>	<geometricalModel \_className\_="Polyhedron" color="{1 0 0}" ...			\\
		\> \> \>	<interactingGeometry \_className\_="Sphere" color="{1 0 0}" ...				\\
		\> \> \>	<boundingVolume \_className\_="AABB" color="{1 0 0}" ...				\\
		\> \> 	<\bs b>
	}

	Whith this library, it is even possible to serialize STL container, basic type such as int, float and types defined into yade-lib-wm3-math, which means you can do something like that : 

	\code
	{
		\> \> 	\float f = 10;							\\
		\> \> 	\kw{vector}<\kw{Vector3}> v;					\\
		\> \> 	v.\kw{push\_back}(Vector3(10, 20, 30));				\\
		\> \> 	v.\kw{push\_back}(Vector3(2.3, 1.7, 4.7));			\\
		\> \> 	v.\kw{push\_back}(Vector3(0, 0, 0));				\\
		\> \> 	IOManager::saveToFile("XMLMAnager", "filef.xml","f",f);		\\
		\> \> 	IOManager::saveToFile("XMLMAnager", "filev.xml","v",v);
	}

and get this result inside filef.xml :

	\code
	{
		\> \> <f>10<\bs f>	
	}

and in file filev.xml :

	\code
	{
		\> \> <v>[ {10 20 30} {2.3 1.7 4.7} {0 0 0} ]<\bs v>	
	}

	The nice last feature of this library is the possibility to (de-)serialize to graphical widget. For now only QT library is supported, only few basic types are supported but it is planned to improve a lot this feature since it is providing automatic generation of graphical user interface. This is what is used to generate the center part of the file generator used into yade to generate initial configuration.


\epsfigure{8cm}{images/serialization2QT.eps}{serialization2QT.}{fig:serialization2qt}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Class factory}

	The class factory provides an easy way of creating new instances of classes. All classes that register themselves into class factory can be asked for instanciation. From a user point of view it is very easy to create a new intance by just calling one of the three functions stored into the class factory singleton : 

	\begin{itemize}
		\item \sharedptr{Factorable} createShared(\str name) : this function creates a shared pointer that points on a factorable class of the given name
		\item Factorable* createPure(\str name ) :  this one creates a C pointer that points on a factorable class of the given name
		\item void * createPureCustom(\str name ) : same for this one but it is returning a void C pointer.
	\end{itemize}
	
Of course this is mainly used to create instances of classes stored into dynamic library. From a used point of view, you asked for a specific instance and the class factory will create it if the class is already in memory, or it will look on the hard drive if a dynamic library has the same name as the requested class instance, then will load the dynamic library and finally will return an instance of this class. This process is totally transparent for the user, so you don't have to care about loading plugin in your code, just ask the factory as follow : 

	\code
	{
		\> \> \sharedptr{Factorable} f\_shared = ClassFactory::instance().createShared("A");
	}
or
	\code
	{
		\> \> Factorable* f\_pure = ClassFactory::instance().createPure("A");
	}
or
	\code
	{
		\> \> void * voidstar = ClassFactory::instance().createCustom("A");
	}

Those lines will create an instance of the class A and return a specific pointer onto it depending of the choosen function. You can then use a static or dynamic cast onto type A to retrieve your specific type : 

	\code
	{
		\> \> sharedptr{A} a\_shared = dynamic\_pointer\_cast<A>(f\_shared);
	}
or 
	\code
	{
		\> \> A * a\_pure = dynamic\_cast<A*>(f\_pure);
	}
or 
	\code
	{
		\> \> A * a\_custom = dynamic\_cast<A*>(voidstar);
	}
	

	To define a factorable class A, you just have to inherit it from class Factorable and then call the macro REGISTER\_CLASS\_NAME with as argument the name of the class. Finally you have to call the REGISTER\_FACTORABLE macro after the definition of your class to register it into the class factory singleton.

	

	\code
	{
		\> \> 	\#include <yade-lib-factory/Factorable.hpp>	\\
									\\
		\> \> 	\class A : \kw{public} Factorable		\\
		\> \>	\{						\\
		\> \> \>	REGISTER\_CLASS\_NAME(A);		\\
		\> \> 	\}						\\
									\\
		\> \>	REGISTER\_FACTORABLE(A);
	}

	All serializable classes also are Factorable that's why you have to call this macro into all classes that inherits Serializable. The REGISTER\_SERIALIZABLE\_CLASS macro calls automatically the REGISTER\_FACTORABLE one that's why you don't have to do it by hand.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Multimethods}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

Here are some ideas :
\begin{itemize}
	\item multi-virtual external method for objects.
	\item objects are becoming POD (in fact not because they inherit from serializable ... but from user point of view it is true) and all method are outside so it is possible to define as many as we want without modifying existing code
	\item All dispatcher (metaengine) are named after what they are modifying/creating/updating ...
	\item optimized dispatching (no if elseif elseif ...)
	\item inside functor possibility to use static\_cast because the dispatching is correct so you know that in the parameter of the functor you have the expected type in the polymorphic pointer.  So no need to use dynamic\_cast followed by a test to know if it was successfull.
\end{itemize}

Dispatching : 2 conditions
	\begin{itemize}
		\item the entity on which we are dispatching has to be multiple (multiple BV,  multiple pair of InteractingGeometry ...)
		\item each functor called by dispatcher have to be independent
			\begin{itemize}
				\item narrow collision between sphere1 and box2 is independent from narrow collision between sphere1 and sphere2
				\item in force displacement method computing a force that is a result of interaction1 is independent from computing a force that is a result of interaction3
				\item in pruning broad collider (SAPCollider) the sort make all the BV not independent so it is not possible to dispatch
using SWIFT and its global scene object make all the objects not independent either.
			\end{itemize}
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{The second layer : the packages and plugins}

	In this layer specific to a field, we are going to define our own bodies, interactions, physicals actions, containers, and engines. Basicaly everything described in previous section can be redifined : new geometricalModel, new interactingGeometry, new boundingVolume, new interactionGeometry, new engines. Even new containers that are specific to your own problem can be rewrited : for exemple if you need fast insertion, fast acccess or fast deletion, you can write a specific container as long as you implement the standard interface.

You have to specify all the customizable element described in previous section.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Creating plugins}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{How to create your own type of body}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{How to create your own type of Interaction}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{How to create your own type of PhysicalAction}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{How to create your own type of Engine}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{How to generate a configuration file}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{How to generate a custom simulation loop}

% using graphical tool

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Creating your own GUI}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Creating your own serialization format}

//				\\
//				\\
// TODO ..........		\\
//				\\
//				\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\addcontentsline{toc}{chapter}{Bibliographie}
%\nocite{*}
%\bibliographystyle{alpha}
%\bibliography{bibliographie}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
