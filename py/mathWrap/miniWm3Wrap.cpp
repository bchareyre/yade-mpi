// This file has been generated by Py++.

#include "boost/python.hpp"

#include "__convenience.pypp.hpp"

#include "__call_policies.pypp.hpp"

#include "miniWm3Wrap-toExpose.hpp"

#include "miniWm3Wrap-funcs.ipp"

namespace bp = boost::python;

static boost::python::tuple ToAxisAngle_2c4febac34e606b4a98de72d9f8161c9( Quaternion< double > const & inst ){
	AngleAxisr aa(angleAxisFromQuat(inst));
    return bp::make_tuple(aa.axis(),aa.angle());
}

BOOST_PYTHON_MODULE(miniEigen){

	std::cerr<<"WARN: Using deprecated Wm3-based math, soon to be removed. Recompile without the 'wm3' feature."<<std::endl;

    { //Matrix3< double >
        typedef bp::class_< Matrix3< double > > Matrix3_exposer_t;
        Matrix3_exposer_t Matrix3_exposer = Matrix3_exposer_t( "Matrix3", bp::init< bp::optional< bool > >(( bp::arg("bZero")=(bool)(true) )) );
        bp::scope Matrix3_scope( Matrix3_exposer );
        bp::implicitly_convertible< bool, Matrix3< double > >();
        Matrix3_exposer.def( bp::init< Matrix3< double > const & >(( bp::arg("rkM") )) );
        Matrix3_exposer.def( bp::init< double, double, double, double, double, double, double, double, double >(( bp::arg("fM00"), bp::arg("fM01"), bp::arg("fM02"), bp::arg("fM10"), bp::arg("fM11"), bp::arg("fM12"), bp::arg("fM20"), bp::arg("fM21"), bp::arg("fM22") )) );
        Matrix3_exposer.def( bp::init< double const *, bool >(( bp::arg("afEntry"), bp::arg("bRowMajor") )) );
        Matrix3_exposer.def( bp::init< Vector3< double > const &, Vector3< double > const &, Vector3< double > const &, bool >(( bp::arg("rkU"), bp::arg("rkV"), bp::arg("rkW"), bp::arg("bColumns") )) );
        Matrix3_exposer.def( bp::init< Vector3< double > const *, bool >(( bp::arg("akV"), bp::arg("bColumns") )) );
        Matrix3_exposer.def( bp::init< double, double, double >(( bp::arg("fM00"), bp::arg("fM11"), bp::arg("fM22") )) );
        { //Matrix3< double >::Adjoint
        
            typedef Matrix3< double > exported_class_t;
            typedef Matrix3< double > ( exported_class_t::*Adjoint_function_type )(  ) const;
            
            Matrix3_exposer.def( 
                "Adjoint"
                , Adjoint_function_type( &Matrix3< double >::Adjoint ) );
        
        }
        { //Matrix3< double >::Determinant
        
            typedef Matrix3< double > exported_class_t;
            typedef double ( exported_class_t::*Determinant_function_type )(  ) const;
            
            Matrix3_exposer.def( 
                "Determinant"
                , Determinant_function_type( &Matrix3< double >::Determinant ) );
        
        }
        { //Matrix3< double >::Determinant
        
            typedef Matrix3< double > exported_class_t;
            typedef double ( exported_class_t::*Determinant_function_type )(  ) const;
            
            Matrix3_exposer.def( 
                "determinant"
                , Determinant_function_type( &Matrix3< double >::Determinant ) );
        
        }
        { //Matrix3< double >::EigenDecomposition
        
            typedef Matrix3< double > exported_class_t;
            typedef void ( exported_class_t::*EigenDecomposition_function_type )( Matrix3< double > &,Matrix3< double > & ) const;
            
            Matrix3_exposer.def( 
                "EigenDecomposition"
                , EigenDecomposition_function_type( &Matrix3< double >::EigenDecomposition )
                , ( bp::arg("rkRot"), bp::arg("rkDiag") ) );
        
        }
        { //Matrix3< double >::FromAxisAngle
        
            typedef Matrix3< double > exported_class_t;
            typedef Matrix3< double > & ( exported_class_t::*FromAxisAngle_function_type )( Vector3< double > const &,double ) ;
            
            Matrix3_exposer.def( 
                "FromAxisAngle"
                , FromAxisAngle_function_type( &Matrix3< double >::FromAxisAngle )
                , ( bp::arg("rkAxis"), bp::arg("fAngle") )
                , bp::return_self< >() );
        
        }
        { //Matrix3< double >::Inverse
        
            typedef Matrix3< double > exported_class_t;
            typedef Matrix3< double > ( exported_class_t::*Inverse_function_type )(  ) const;
            
            Matrix3_exposer.def( 
                "Inverse"
                , Inverse_function_type( &Matrix3< double >::Inverse ) );
        
        }
        { //Matrix3< double >::Inverse
        
            typedef Matrix3< double > exported_class_t;
            typedef Matrix3< double > ( exported_class_t::*Inverse_function_type )(  ) const;
            
            Matrix3_exposer.def( 
                "inverse"
                , Inverse_function_type( &Matrix3< double >::Inverse ) );
        
        }
        { //Matrix3< double >::Transpose
        
            typedef Matrix3< double > exported_class_t;
            typedef Matrix3< double > ( exported_class_t::*Transpose_function_type )(  ) const;
            
            Matrix3_exposer.def( 
                "Transpose"
                , Transpose_function_type( &Matrix3< double >::Transpose ) );
        
        }
        { //Matrix3< double >::Transpose
        
            typedef Matrix3< double > exported_class_t;
            typedef Matrix3< double > ( exported_class_t::*Transpose_function_type )(  ) const;
            
            Matrix3_exposer.def( 
                "transpose"
                , Transpose_function_type( &Matrix3< double >::Transpose ) );
        
        }
        Matrix3_exposer.def( bp::self != bp::self );
        { //Matrix3< double >::operator()
        
            typedef Matrix3< double > exported_class_t;
            typedef double ( exported_class_t::*__call___function_type )( int,int ) const;
            
            Matrix3_exposer.def( 
                "__call__"
                , __call___function_type( &Matrix3< double >::operator() )
                , ( bp::arg("iRow"), bp::arg("iCol") ) );
        
        }
        Matrix3_exposer.def( bp::self * bp::self );
        Matrix3_exposer.def( bp::self * bp::other< double >() );
        Matrix3_exposer.def( bp::self * bp::other< Vector3< double > >() );
        Matrix3_exposer.def( bp::self *= bp::other< double >() );
        Matrix3_exposer.def( bp::self + bp::self );
        Matrix3_exposer.def( bp::self += bp::self );
        Matrix3_exposer.def( bp::self - bp::self );
        Matrix3_exposer.def( -bp::self );
        Matrix3_exposer.def( bp::self -= bp::self );
        Matrix3_exposer.def( bp::self / bp::other< double >() );
        Matrix3_exposer.def( bp::self /= bp::other< double >() );
        Matrix3_exposer.def( bp::self < bp::self );
        Matrix3_exposer.def( bp::self <= bp::self );
        { //Matrix3< double >::operator=
        
            typedef Matrix3< double > exported_class_t;
            typedef Matrix3< double > & ( exported_class_t::*assign_function_type )( Matrix3< double > const & ) ;
            
            Matrix3_exposer.def( 
                "assign"
                , assign_function_type( &Matrix3< double >::operator= )
                , ( bp::arg("rkM") )
                , bp::return_self< >() );
        
        }
        Matrix3_exposer.def( bp::self == bp::self );
        Matrix3_exposer.def( bp::self > bp::self );
        Matrix3_exposer.def( bp::self >= bp::self );
        Matrix3_exposer.def( bp::other< Real >() * bp::self );
        Matrix3_exposer.def("__len__",&::Matrix3_len).staticmethod("__len__")   .def("__setitem__",&::Matrix3_set_item)   .def("__getitem__",&::Matrix3_get_item)   .def("__str__",&::Matrix3_str)   .def("__repr__",&::Matrix3_str)  /* extras for matrices */ .def("__setitem__",&::Matrix3_set_item_linear).def("__getitem__",&::Matrix3_get_item_linear);
        Matrix3_exposer.add_property("ZERO",::Matrix3r_ZERO).add_property("IDENTITY",::Matrix3r_IDENTITY);
        Matrix3_exposer.add_property("Zero",::Matrix3r_ZERO).add_property("Identity",::Matrix3r_IDENTITY);
    }

    { //Quaternion< double >
        typedef bp::class_< Quaternion< double > > Quaternion_exposer_t;
        Quaternion_exposer_t Quaternion_exposer = Quaternion_exposer_t( "Quaternion", bp::init< >() );
        bp::scope Quaternion_scope( Quaternion_exposer );
        Quaternion_exposer.def( bp::init< double, double, double, double >(( bp::arg("fW"), bp::arg("fX"), bp::arg("fY"), bp::arg("fZ") )) );
        Quaternion_exposer.def( bp::init< Quaternion< double > const & >(( bp::arg("rkQ") )) );
        Quaternion_exposer.def( bp::init< Matrix3< double > const & >(( bp::arg("rkRot") )) );
        bp::implicitly_convertible< Matrix3< double > const &, Quaternion< double > >();
        Quaternion_exposer.def( bp::init< Vector3< double > const &, double >(( bp::arg("rkAxis"), bp::arg("fAngle") )) );
        Quaternion_exposer.def( bp::init< Vector3< double > const * >(( bp::arg("akRotColumn") )) );
        bp::implicitly_convertible< Vector3< double > const *, Quaternion< double > >();
        { //Quaternion< double >::Align
        
            typedef Quaternion< double > exported_class_t;
            typedef Quaternion< double > & ( exported_class_t::*Align_function_type )( Vector3< double > const &,Vector3< double > const & ) ;
            
            Quaternion_exposer.def( 
                "Align"
                , Align_function_type( &Quaternion< double >::Align )
                , ( bp::arg("rkV1"), bp::arg("rkV2") )
                , bp::return_self< >() );
        
        }
        { //Quaternion< double >::Align
        
            typedef Quaternion< double > exported_class_t;
            typedef Quaternion< double > & ( exported_class_t::*Align_function_type )( Vector3< double > const &,Vector3< double > const & ) ;
            
            Quaternion_exposer.def( 
                "setFromTwoVectors"
                , Align_function_type( &Quaternion< double >::Align )
                , ( bp::arg("rkV1"), bp::arg("rkV2") )
                , bp::return_self< >() );
        
        }
        { //Quaternion< double >::Conjugate
        
            typedef Quaternion< double > exported_class_t;
            typedef Quaternion< double > ( exported_class_t::*Conjugate_function_type )(  ) const;
            
            Quaternion_exposer.def( 
                "Conjugate"
                , Conjugate_function_type( &Quaternion< double >::Conjugate ) );
        
        }
        { //Quaternion< double >::ToRotationMatrix
        
            typedef Quaternion< double > exported_class_t;
            typedef Quaternion< double > ( exported_class_t::*ToRotationMatrix_function_type )(  ) const;
            
            Quaternion_exposer.def( 
                "ToRotationMatrix"
                , ToRotationMatrix_function_type( &Quaternion< double >::toRotationMatrix ) );
        
        }
        { //Quaternion< double >::ToRotationMatrix
        
            typedef Quaternion< double > exported_class_t;
            typedef Quaternion< double > ( exported_class_t::*ToRotationMatrix_function_type )(  ) const;
            
            Quaternion_exposer.def( 
                "toRotationMatrix"
                , ToRotationMatrix_function_type( &Quaternion< double >::toRotationMatrix ) );
        
        }
        { //Quaternion< double >::Conjugate
        
            typedef Quaternion< double > exported_class_t;
            typedef Quaternion< double > ( exported_class_t::*Conjugate_function_type )(  ) const;
            
            Quaternion_exposer.def( 
                "conjugate"
                , Conjugate_function_type( &Quaternion< double >::Conjugate ) );
        
        }
        { //Quaternion< double >::FromAxisAngle
        
            typedef Quaternion< double > exported_class_t;
            typedef Quaternion< double > & ( exported_class_t::*FromAxisAngle_function_type )( Vector3< double > const &,double ) ;
            
            Quaternion_exposer.def( 
                "FromAxisAngle"
                , FromAxisAngle_function_type( &Quaternion< double >::FromAxisAngle )
                , ( bp::arg("rkAxis"), bp::arg("fAngle") )
                , bp::return_self< >() );
        
        }
        { //Quaternion< double >::Inverse
        
            typedef Quaternion< double > exported_class_t;
            typedef Quaternion< double > ( exported_class_t::*Inverse_function_type )(  ) const;
            
            Quaternion_exposer.def( 
                "Inverse"
                , Inverse_function_type( &Quaternion< double >::Inverse ) );
        
        }
        { //Quaternion< double >::Normalize
        
            typedef Quaternion< double > exported_class_t;
            typedef double ( exported_class_t::*Normalize_function_type )(  ) ;
            
            Quaternion_exposer.def( 
                "Normalize"
                , Normalize_function_type( &Quaternion< double >::Normalize ) );
        
        }
        { //Quaternion< double >::Inverse
        
            typedef Quaternion< double > exported_class_t;
            typedef Quaternion< double > ( exported_class_t::*Inverse_function_type )(  ) const;
            
            Quaternion_exposer.def( 
                "inverse"
                , Inverse_function_type( &Quaternion< double >::Inverse ) );
        
        }
        { //Quaternion< double >::Normalize
        
            typedef Quaternion< double > exported_class_t;
            typedef double ( exported_class_t::*Normalize_function_type )(  ) ;
            
            Quaternion_exposer.def( 
                "normalize"
                , Normalize_function_type( &Quaternion< double >::Normalize ) );
        
        }
        { //Quaternion< double >::Rotate
        
            typedef Quaternion< double > exported_class_t;
            typedef Vector3< double > ( exported_class_t::*Rotate_function_type )( Vector3< double > const & ) const;
            
            Quaternion_exposer.def( 
                "Rotate"
                , Rotate_function_type( &Quaternion< double >::Rotate )
                , ( bp::arg("rkVector") ) );
        
        }
        { //Quaternion< double >::ToAxisAngle
        
            typedef Quaternion< double > exported_class_t;
            typedef boost::python::tuple ( *ToAxisAngle_function_type )( Quaternion<double> const & );
            
            Quaternion_exposer.def( 
                "ToAxisAngle"
                , ToAxisAngle_function_type( &ToAxisAngle_2c4febac34e606b4a98de72d9f8161c9 )
                , ( bp::arg("inst") ) );
        
        }
        { //Quaternion< double >::ToAxisAngle
        
            typedef Quaternion< double > exported_class_t;
            typedef boost::python::tuple ( *ToAxisAngle_function_type )( Quaternion<double> const & );
            
            Quaternion_exposer.def( 
                "toAxisAngle"
                , ToAxisAngle_function_type( &ToAxisAngle_2c4febac34e606b4a98de72d9f8161c9 )
                , ( bp::arg("inst") ) );
        
        }
        { //Quaternion< double >::W
        
            typedef Quaternion< double > exported_class_t;
            typedef double ( exported_class_t::*W_function_type )(  ) const;
            
            Quaternion_exposer.def( 
                "W"
                , W_function_type( &Quaternion< double >::W ) );
        
        }
        { //Quaternion< double >::X
        
            typedef Quaternion< double > exported_class_t;
            typedef double ( exported_class_t::*X_function_type )(  ) const;
            
            Quaternion_exposer.def( 
                "X"
                , X_function_type( &Quaternion< double >::X ) );
        
        }
        { //Quaternion< double >::Y
        
            typedef Quaternion< double > exported_class_t;
            typedef double ( exported_class_t::*Y_function_type )(  ) const;
            
            Quaternion_exposer.def( 
                "Y"
                , Y_function_type( &Quaternion< double >::Y ) );
        
        }
        { //Quaternion< double >::Z
        
            typedef Quaternion< double > exported_class_t;
            typedef double ( exported_class_t::*Z_function_type )(  ) const;
            
            Quaternion_exposer.def( 
                "Z"
                , Z_function_type( &Quaternion< double >::Z ) );
        
        }
        { //Quaternion< double >::W
        
            typedef Quaternion< double > exported_class_t;
            typedef double ( exported_class_t::*W_function_type )(  ) const;
            
            Quaternion_exposer.def( 
                "w"
                , W_function_type( &Quaternion< double >::W ) );
        
        }
        { //Quaternion< double >::X
        
            typedef Quaternion< double > exported_class_t;
            typedef double ( exported_class_t::*X_function_type )(  ) const;
            
            Quaternion_exposer.def( 
                "x"
                , X_function_type( &Quaternion< double >::X ) );
        
        }
        { //Quaternion< double >::Y
        
            typedef Quaternion< double > exported_class_t;
            typedef double ( exported_class_t::*Y_function_type )(  ) const;
            
            Quaternion_exposer.def( 
                "y"
                , Y_function_type( &Quaternion< double >::Y ) );
        
        }
        { //Quaternion< double >::Z
        
            typedef Quaternion< double > exported_class_t;
            typedef double ( exported_class_t::*Z_function_type )(  ) const;
            
            Quaternion_exposer.def( 
                "z"
                , Z_function_type( &Quaternion< double >::Z ) );
        
        }
        Quaternion_exposer.def( bp::self != bp::self );
        Quaternion_exposer.def( bp::self * bp::self );
        Quaternion_exposer.def( bp::self * bp::other< double >() );
        Quaternion_exposer.def( bp::self *= bp::other< double >() );
        Quaternion_exposer.def( bp::self + bp::self );
        Quaternion_exposer.def( bp::self += bp::self );
        Quaternion_exposer.def( bp::self - bp::self );
        Quaternion_exposer.def( -bp::self );
        Quaternion_exposer.def( bp::self -= bp::self );
        Quaternion_exposer.def( bp::self / bp::other< double >() );
        Quaternion_exposer.def( bp::self /= bp::other< double >() );
        Quaternion_exposer.def( bp::self < bp::self );
        Quaternion_exposer.def( bp::self <= bp::self );
        { //Quaternion< double >::operator=
        
            typedef Quaternion< double > exported_class_t;
            typedef Quaternion< double > & ( exported_class_t::*assign_function_type )( Quaternion< double > const & ) ;
            
            Quaternion_exposer.def( 
                "assign"
                , assign_function_type( &Quaternion< double >::operator= )
                , ( bp::arg("rkQ") )
                , bp::return_self< >() );
        
        }
        Quaternion_exposer.def( bp::self == bp::self );
        Quaternion_exposer.def( bp::self > bp::self );
        Quaternion_exposer.def( bp::self >= bp::self );
        Quaternion_exposer.def( bp::self * bp::other< Vector3< double > >() );
        Quaternion_exposer.def( bp::self_ns::str( bp::self ) );
        Quaternion_exposer.def("__len__",&::Quaternion_len).staticmethod("__len__").def("__setitem__",&::Quaternion_set_item).def("__getitem__",&::Quaternion_get_item).def("__str__",&::Quaternion_str).def("__repr__",&::Quaternion_str);
        Quaternion_exposer.add_property("IDENTITY",::Quaternionr_IDENTITY);
        Quaternion_exposer.add_property("Identity",::Quaternionr_IDENTITY);
    }

    { //Vector2< double >
        typedef bp::class_< Vector2< double > > Vector2_exposer_t;
        Vector2_exposer_t Vector2_exposer = Vector2_exposer_t( "Vector2", bp::init< >() );
        bp::scope Vector2_scope( Vector2_exposer );
        Vector2_exposer.def( bp::init< double, double >(( bp::arg("fX"), bp::arg("fY") )) );
        Vector2_exposer.def( bp::init< double const * >(( bp::arg("afTuple") )) );
        bp::implicitly_convertible< double const *, Vector2< double > >();
        Vector2_exposer.def( bp::init< Vector2< double > const & >(( bp::arg("rkV") )) );
        { //Vector2< double >::Dot
        
            typedef Vector2< double > exported_class_t;
            typedef double ( exported_class_t::*Dot_function_type )( Vector2< double > const & ) const;
            
            Vector2_exposer.def( 
                "Dot"
                , Dot_function_type( &Vector2< double >::Dot )
                , ( bp::arg("rkV") ) );
        
        }
        { //Vector2< double >::Length
        
            typedef Vector2< double > exported_class_t;
            typedef double ( exported_class_t::*Length_function_type )(  ) const;
            
            Vector2_exposer.def( 
                "Length"
                , Length_function_type( &Vector2< double >::Length ) );
        
        }
        { //Vector2< double >::Normalize
        
            typedef Vector2< double > exported_class_t;
            typedef double ( exported_class_t::*Normalize_function_type )(  ) ;
            
            Vector2_exposer.def( 
                "Normalize"
                , Normalize_function_type( &Vector2< double >::Normalize ) );
        
        }
        { //Vector2< double >::SquaredLength
        
            typedef Vector2< double > exported_class_t;
            typedef double ( exported_class_t::*SquaredLength_function_type )(  ) const;
            
            Vector2_exposer.def( 
                "SquaredLength"
                , SquaredLength_function_type( &Vector2< double >::SquaredLength ) );
        
        }
        { //Vector2< double >::Dot
        
            typedef Vector2< double > exported_class_t;
            typedef double ( exported_class_t::*Dot_function_type )( Vector2< double > const & ) const;
            
            Vector2_exposer.def( 
                "dot"
                , Dot_function_type( &Vector2< double >::Dot )
                , ( bp::arg("rkV") ) );
        
        }
        { //Vector2< double >::Length
        
            typedef Vector2< double > exported_class_t;
            typedef double ( exported_class_t::*Length_function_type )(  ) const;
            
            Vector2_exposer.def( 
                "norm"
                , Length_function_type( &Vector2< double >::Length ) );
        
        }
        { //Vector2< double >::Normalize
        
            typedef Vector2< double > exported_class_t;
            typedef double ( exported_class_t::*Normalize_function_type )(  ) ;
            
            Vector2_exposer.def( 
                "normalize"
                , Normalize_function_type( &Vector2< double >::Normalize ) );
        
        }
        { //Vector2< double >::SquaredLength
        
            typedef Vector2< double > exported_class_t;
            typedef double ( exported_class_t::*SquaredLength_function_type )(  ) const;
            
            Vector2_exposer.def( 
                "squaredNorm"
                , SquaredLength_function_type( &Vector2< double >::SquaredLength ) );
        
        }
        { //Vector2< double >::X
        
            typedef Vector2< double > exported_class_t;
            typedef double ( exported_class_t::*X_function_type )(  ) const;
            
            Vector2_exposer.def( 
                "X"
                , X_function_type( &Vector2< double >::X ) );
        
        }
        { //Vector2< double >::Y
        
            typedef Vector2< double > exported_class_t;
            typedef double ( exported_class_t::*Y_function_type )(  ) const;
            
            Vector2_exposer.def( 
                "Y"
                , Y_function_type( &Vector2< double >::Y ) );
        
        }
        { //Vector2< double >::X
        
            typedef Vector2< double > exported_class_t;
            typedef double ( exported_class_t::*X_function_type )(  ) const;
            
            Vector2_exposer.def( 
                "x"
                , X_function_type( &Vector2< double >::X ) );
        
        }
        { //Vector2< double >::Y
        
            typedef Vector2< double > exported_class_t;
            typedef double ( exported_class_t::*Y_function_type )(  ) const;
            
            Vector2_exposer.def( 
                "y"
                , Y_function_type( &Vector2< double >::Y ) );
        
        }
        Vector2_exposer.def( bp::self != bp::self );
        Vector2_exposer.def( bp::self * bp::other< double >() );
        Vector2_exposer.def( bp::self *= bp::other< double >() );
        Vector2_exposer.def( bp::self + bp::self );
        Vector2_exposer.def( bp::self += bp::self );
        Vector2_exposer.def( bp::self - bp::self );
        Vector2_exposer.def( -bp::self );
        Vector2_exposer.def( bp::self -= bp::self );
        Vector2_exposer.def( bp::self / bp::other< double >() );
        Vector2_exposer.def( bp::self /= bp::other< double >() );
        Vector2_exposer.def( bp::self < bp::self );
        Vector2_exposer.def( bp::self <= bp::self );
        { //Vector2< double >::operator=
        
            typedef Vector2< double > exported_class_t;
            typedef Vector2< double > & ( exported_class_t::*assign_function_type )( Vector2< double > const & ) ;
            
            Vector2_exposer.def( 
                "assign"
                , assign_function_type( &Vector2< double >::operator= )
                , ( bp::arg("rkV") )
                , bp::return_self< >() );
        
        }
        Vector2_exposer.def( bp::self == bp::self );
        Vector2_exposer.def( bp::self > bp::self );
        Vector2_exposer.def( bp::self >= bp::self );
        Vector2_exposer.def( bp::other< Real >() * bp::self );
        Vector2_exposer.def("__len__",&::Vector2_len)   .staticmethod("__len__").def("__setitem__",&::Vector2_set_item)   .def("__getitem__",&::Vector2_get_item)   .def("__str__",&::Vector2_str)   .def("__repr__",&::Vector2_str);
        Vector2_exposer.add_property("ZERO",::Vector2r_ZERO).add_property("UNIT_X",::Vector2r_UNIT_X).add_property("UNIT_Y",::Vector2r_UNIT_Y).add_property("ONE",::Vector2r_ONE);
        Vector2_exposer.add_property("Zero",::Vector2r_ZERO).add_property("UnitX",::Vector2r_UNIT_X).add_property("UnitY",::Vector2r_UNIT_Y).add_property("Ones",::Vector2r_ONE);
    }

    custom_Vector3r_from_tuple();

    { //Vector3< double >
        typedef bp::class_< Vector3< double > > Vector3_exposer_t;
        Vector3_exposer_t Vector3_exposer = Vector3_exposer_t( "Vector3", bp::init< >() );
        bp::scope Vector3_scope( Vector3_exposer );
        Vector3_exposer.def( bp::init< double, double, double >(( bp::arg("fX"), bp::arg("fY"), bp::arg("fZ") )) );
        Vector3_exposer.def( bp::init< double const * >(( bp::arg("afTuple") )) );
        bp::implicitly_convertible< double const *, Vector3< double > >();
        Vector3_exposer.def( bp::init< Vector3< double > const & >(( bp::arg("rkV") )) );
        { //Vector3< double >::Cross
        
            typedef Vector3< double > exported_class_t;
            typedef Vector3< double > ( exported_class_t::*Cross_function_type )( Vector3< double > const & ) const;
            
            Vector3_exposer.def( 
                "Cross"
                , Cross_function_type( &Vector3< double >::Cross )
                , ( bp::arg("rkV") ) );
        
        }
        { //Vector3< double >::Dot
        
            typedef Vector3< double > exported_class_t;
            typedef double ( exported_class_t::*Dot_function_type )( Vector3< double > const & ) const;
            
            Vector3_exposer.def( 
                "Dot"
                , Dot_function_type( &Vector3< double >::Dot )
                , ( bp::arg("rkV") ) );
        
        }
        { //Vector3< double >::Length
        
            typedef Vector3< double > exported_class_t;
            typedef double ( exported_class_t::*Length_function_type )(  ) const;
            
            Vector3_exposer.def( 
                "Length"
                , Length_function_type( &Vector3< double >::Length ) );
        
        }
        { //Vector3< double >::Normalize
        
            typedef Vector3< double > exported_class_t;
            typedef double ( exported_class_t::*Normalize_function_type )(  ) ;
            
            Vector3_exposer.def( 
                "Normalize"
                , Normalize_function_type( &Vector3< double >::Normalize ) );
        
        }
        { //Vector3< double >::SquaredLength
        
            typedef Vector3< double > exported_class_t;
            typedef double ( exported_class_t::*SquaredLength_function_type )(  ) const;
            
            Vector3_exposer.def( 
                "SquaredLength"
                , SquaredLength_function_type( &Vector3< double >::SquaredLength ) );
        
        }
        { //Vector3< double >::X
        
            typedef Vector3< double > exported_class_t;
            typedef double ( exported_class_t::*X_function_type )(  ) const;
            
            Vector3_exposer.def( 
                "X"
                , X_function_type( &Vector3< double >::X ) );
        
        }
        { //Vector3< double >::Y
        
            typedef Vector3< double > exported_class_t;
            typedef double ( exported_class_t::*Y_function_type )(  ) const;
            
            Vector3_exposer.def( 
                "Y"
                , Y_function_type( &Vector3< double >::Y ) );
        
        }
        { //Vector3< double >::Z
        
            typedef Vector3< double > exported_class_t;
            typedef double ( exported_class_t::*Z_function_type )(  ) const;
            
            Vector3_exposer.def( 
                "Z"
                , Z_function_type( &Vector3< double >::Z ) );
        
        }
        { //Vector3< double >::Cross
        
            typedef Vector3< double > exported_class_t;
            typedef Vector3< double > ( exported_class_t::*Cross_function_type )( Vector3< double > const & ) const;
            
            Vector3_exposer.def( 
                "cross"
                , Cross_function_type( &Vector3< double >::Cross )
                , ( bp::arg("rkV") ) );
        
        }
        { //Vector3< double >::Dot
        
            typedef Vector3< double > exported_class_t;
            typedef double ( exported_class_t::*Dot_function_type )( Vector3< double > const & ) const;
            
            Vector3_exposer.def( 
                "dot"
                , Dot_function_type( &Vector3< double >::Dot )
                , ( bp::arg("rkV") ) );
        
        }
        { //Vector3< double >::Length
        
            typedef Vector3< double > exported_class_t;
            typedef double ( exported_class_t::*Length_function_type )(  ) const;
            
            Vector3_exposer.def( 
                "norm"
                , Length_function_type( &Vector3< double >::Length ) );
        
        }
        { //Vector3< double >::Normalize
        
            typedef Vector3< double > exported_class_t;
            typedef double ( exported_class_t::*Normalize_function_type )(  ) ;
            
            Vector3_exposer.def( 
                "normalize"
                , Normalize_function_type( &Vector3< double >::Normalize ) );
        
        }
        { //Vector3< double >::SquaredLength
        
            typedef Vector3< double > exported_class_t;
            typedef double ( exported_class_t::*SquaredLength_function_type )(  ) const;
            
            Vector3_exposer.def( 
                "squaredNorm"
                , SquaredLength_function_type( &Vector3< double >::SquaredLength ) );
        
        }
        { //Vector3< double >::X
        
            typedef Vector3< double > exported_class_t;
            typedef double ( exported_class_t::*X_function_type )(  ) const;
            
            Vector3_exposer.def( 
                "x"
                , X_function_type( &Vector3< double >::X ) );
        
        }
        { //Vector3< double >::Y
        
            typedef Vector3< double > exported_class_t;
            typedef double ( exported_class_t::*Y_function_type )(  ) const;
            
            Vector3_exposer.def( 
                "y"
                , Y_function_type( &Vector3< double >::Y ) );
        
        }
        { //Vector3< double >::Z
        
            typedef Vector3< double > exported_class_t;
            typedef double ( exported_class_t::*Z_function_type )(  ) const;
            
            Vector3_exposer.def( 
                "z"
                , Z_function_type( &Vector3< double >::Z ) );
        
        }
        Vector3_exposer.def( bp::self != bp::self );
        Vector3_exposer.def( bp::self * bp::other< double >() );
        Vector3_exposer.def( bp::self *= bp::other< double >() );
        Vector3_exposer.def( bp::self + bp::self );
        Vector3_exposer.def( bp::self += bp::self );
        Vector3_exposer.def( bp::self - bp::self );
        Vector3_exposer.def( -bp::self );
        Vector3_exposer.def( bp::self -= bp::self );
        Vector3_exposer.def( bp::self / bp::other< double >() );
        Vector3_exposer.def( bp::self /= bp::other< double >() );
        Vector3_exposer.def( bp::self < bp::self );
        Vector3_exposer.def( bp::self <= bp::self );
        { //Vector3< double >::operator=
        
            typedef Vector3< double > exported_class_t;
            typedef Vector3< double > & ( exported_class_t::*assign_function_type )( Vector3< double > const & ) ;
            
            Vector3_exposer.def( 
                "assign"
                , assign_function_type( &Vector3< double >::operator= )
                , ( bp::arg("rkV") )
                , bp::return_self< >() );
        
        }
        Vector3_exposer.def( bp::self == bp::self );
        Vector3_exposer.def( bp::self > bp::self );
        Vector3_exposer.def( bp::self >= bp::self );
        Vector3_exposer.def( bp::self * bp::other< Matrix3< double > >() );
        Vector3_exposer.def( bp::self_ns::str( bp::self ) );
        Vector3_exposer.def("__len__",&::Vector3_len)   .staticmethod("__len__").def("__setitem__",&::Vector3_set_item)   .def("__getitem__",&::Vector3_get_item)   .def("__str__",&::Vector3_str)   .def("__repr__",&::Vector3_str);
        Vector3_exposer.add_property("ZERO",::Vector3r_ZERO).add_property("UNIT_X",::Vector3r_UNIT_X).add_property("UNIT_Y",::Vector3r_UNIT_Y).add_property("UNIT_Z",::Vector3r_UNIT_Z).add_property("ONE",::Vector3r_ONE);
        Vector3_exposer.add_property("Zero",::Vector3r_ZERO).add_property("UnitX",::Vector3r_UNIT_X).add_property("UnitY",::Vector3r_UNIT_Y).add_property("UnitZ",::Vector3r_UNIT_Z).add_property("Ones",::Vector3r_ONE);
    }
}
