#!/usr/bin/env python

# This scripts attempts to replace deprecated symbols by their new equivalents based on compiler's output log. Symbol map must be
# given explicitly (see renamedSymbols below).
#
# The only command-line argument is yade's buildRoot (trunk) directory. This script further on the fact that all filenames reported
# in compiler's warnings are relative to the buildRoot. Therefore, you better use scons to compile, since default Makefile are recursive.
#
# Build log (like "scons >build.log 2>&1") is piped from standard input. It MUST be strictly sequential, i.e. no -j2 etc.
#
# You may have to adjust the runCxxPattern below depending on the compiler you use. It must distinguish a compiler invocation.
runCxxPattern=r'^((c|g|so)\+\+|ccache|distcc).*$'
#
# Likewise for deprecatedPattern. It must have the following groups: file, line, symbol.
# This one works for g++4.0 and possibly other compilers.
deprecatedPattern=r"^(.*?):([0-9]+): warning: '([_a-zA-Z0-9]+)' is deprecated.*$"
#
# All files modified are backed up to their directory with some extension like .~undeprecated~.
#


import sys
from re import *
import logging
from os.path import join
import shutil
from pprint import pprint

logging.basicConfig(level=logging.DEBUG)

#
# these symbols are class methods. Several of them are the same (like Vector{2,3}.x()), but they have been
# fortunately renamed the same for all classes. So we don't need to distinguish that.
#
# the dictionary was generated by hackett2.py from tags files
#
renamedSymbols={
	'aCos':'ACos',
	'aSin':'ASin',
	'aTan':'ATan',
	'aTan2':'ATan2',
	'adjoint':'Adjoint',
	'align':'Align',
	'bidiagonalize':'Bidiagonalize',
	'compareArrays':'CompareArrays',
	'conjugate':'Conjugate',
	'cosinus':'Cos',
	'cross':'Cross',
	'decomposeSwingTimesTwist':'DecomposeSwingTimesTwist',
	'decomposeTwistTimesSwing':'DecomposeTwistTimesSwing',
	'determinant':'Determinant',
	'diagonalTimes':'DiagonalTimes',
	'dot':'Dot',
	'dotPerp':'DotPerp',
	'eExp':'Exp',
	'eigenDecomposition':'EigenDecomposition',
	'exp':'Exp',
	'fAbs':'FAbs',
	'fMod':'FMod',
	'fastCos0':'FastCos0',
	'fastCos1':'FastCos1',
	'fastInvCos0':'FastInvCos0',
	'fastInvCos1':'FastInvCos1',
	'fastInvSin0':'FastInvSin0',
	'fastInvSin1':'FastInvSin1',
	'fastInvSqrt':'FastInvSqrt',
	'fastInvTan0':'FastInvTan0',
	'fastInvTan1':'FastInvTan1',
	'fastSin0':'FastSin0',
	'fastSin1':'FastSin1',
	'fastTan0':'FastTan0',
	'fastTan1':'FastTan1',
	'fromAngle':'FromAngle',
	'fromAxisAngle':'FromAxisAngle',
	'fromEulerAnglesXYZ':'FromEulerAnglesXYZ',
	'fromEulerAnglesXZY':'FromEulerAnglesXZY',
	'fromEulerAnglesYXZ':'FromEulerAnglesYXZ',
	'fromEulerAnglesYZX':'FromEulerAnglesYZX',
	'fromEulerAnglesZXY':'FromEulerAnglesZXY',
	'fromEulerAnglesZYX':'FromEulerAnglesZYX',
	'fromRotationMatrix':'FromRotationMatrix',
	'generateOrthonormalBasis':'GenerateOrthonormalBasis',
	'getBarycentrics':'GetBarycentrics',
	'getColumn':'GetColumn',
	'getColumnMajor':'GetColumnMajor',
	'getRow':'GetRow',
	'golubKahanStep':'GolubKahanStep',
	'intermediate':'Intermediate',
	'intervalRandom':'IntervalRandom',
	'invSqRoot':'InvSqrt',
	'inverse':'Inverse',
	'length':'Length',
	'log':'Log',
	'logarithm':'Log',
	'makeDiagonal':'MakeDiagonal',
	'makeIdentity':'MakeIdentity',
	'makeObliqueProjection':'MakeObliqueProjection',
	'makePerspectiveProjection':'MakePerspectiveProjection',
	'makeReflection':'MakeReflection',
	'makeTensorProduct':'MakeTensorProduct',
	'makeZero':'MakeZero',
	'normalize':'Normalize',
	'orthonormalize':'Orthonormalize',
	'perp':'Perp',
	'power':'Pow',
	'qForm':'QForm',
	'rotate':'Rotate',
	'roundDown':'Floor',
	'roundUp':'Ceil',
	'setColumn':'SetColumn',
	'setRow':'SetRow',
	'sign':'Sign',
	'singularValueComposition':'SingularValueComposition',
	'singularValueDecomposition':'SingularValueDecomposition',
	'sinus':'Sin',
	'slerp':'Slerp',
	'slerpExtraSpins':'SlerpExtraSpins',
	'sqRoot':'Sqrt',
	'sqr':'Sqr',
	'squad':'Squad',
	'squaredLength':'SquaredLength',
	'symmetricRandom':'SymmetricRandom',
	'tangent':'Tan',
	'timesDiagonal':'TimesDiagonal',
	'timesTranspose':'TimesTranspose',
	'toAngle':'ToAngle',
	'toAxisAngle':'ToAxisAngle',
	'toEulerAnglesXYZ':'ToEulerAnglesXYZ',
	'toEulerAnglesXZY':'ToEulerAnglesXZY',
	'toEulerAnglesYXZ':'ToEulerAnglesYXZ',
	'toEulerAnglesYZX':'ToEulerAnglesYZX',
	'toEulerAnglesZXY':'ToEulerAnglesZXY',
	'toEulerAnglesZYX':'ToEulerAnglesZYX',
	'toRotationMatrix':'ToRotationMatrix',
	'transpose':'Transpose',
	'transposeTimes':'TransposeTimes',
	'tridiagonalize':'Tridiagonalize',
	'unitCross':'UnitCross',
	'unitPerp':'UnitPerp',
	'unitRandom':'UnitRandom',
	'w':'W',
	'x':'X',
	'y':'Y',
	'z':'Z'}

# places where deprecated methods are used
# keys are symbols, value is a list of (file,line,count)
# this is the global dictionary
D={}
# dtto, but for one individual compiler run; changes are merged to D afterwards
D1={}
# count of deprecation warnings, only for the heck of informing the user of what is going on
Dcount=0


# Symbols at different lines than the compiler reports.
# Maps (symbol,file,line_as_reported_by_compiler) -> real_line.
# We are not intelligent enough to do fuzzy match on line number.
Doffsets={('sqRoot','include/yade/yade-lib-wm3-math/Quaternion.ipp',459):455,
	('sqRoot','include/yade/yade-lib-wm3-math/Vector3.ipp',270):267,
	('x','include/yade/yade-lib-serialization/KnownFundamentalsHandler.tpp',187):188,
	('y','include/yade/yade-lib-serialization/KnownFundamentalsHandler.tpp',187):190,
	('z','include/yade/yade-lib-serialization/KnownFundamentalsHandler.tpp',187):192,
	('sqRoot','include/yade/yade-lib-wm3-math/Vector2.ipp',243):241}

# parse the build log as fed by stdin
for l in sys.stdin.xreadlines():
	if match(runCxxPattern,l): #initialization, i.e. the compiler being run; until the next compiler run or EOF, all messages belong to this compilation.
		# merge dictonary from the previous compiler run
		for s in D1.keys():
			if not s in D.keys(): # new symbol; simply add
				D[s]=D1[s]
				continue
			# OK, now s is in D already
			for ss1 in D1[s]: # iterate over locations for symbol s from this compilation
				done=False # tmp to break the outer loop from the nested one
				for ss in D[s]: # iterate over locations from all previous compilations
					if ss[0]!=ss1[0]: continue # file doesn't match, doesn't belong here
					if ss[1]!=ss1[1]: continue # line doesn't match, dtto
					# here, symbol, file, and line match. Make sure that count also matches. It should.
					if ss[2]==ss1[2]: # this is OK. Last compilation all report that symbole the same number of times for that line
						done=True
					else:
						logging.error("%s:%d: Deprecations warning number doesn't match for `%s'"%(file,line))
						# since it is a fatal logic error, bail out
						assert(1==0)
				if done: continue
				D[s].append(ss1) # warning not yet encountered at this place exactly
		# now hashes have been merged
		D1={}
		continue # this input line is not further processed

	# deprecation warning from the compiler
	dep=match(deprecatedPattern,l)
	if dep:
		file=dep.group(1)
		line=int(dep.group(2))
		symbol=dep.group(3)
		# this indicates inconsistency of what symbols are marked as deprecated and what we think these are
		if not symbol in renamedSymbols.keys():
			logging.error("%s:%d: Unknown symbol `%s' reported as deprecated?!"%file,line,symbol)
			continue
		Dcount+=1
		# handle cases where compiler reports wrong line number: adjust the line number
		if (symbol,file,line) in Doffsets.keys(): line=Doffsets[(symbol,file,line)]
		if not symbol in D1.keys(): # first warning emitted for this symbol in this file
			D1[symbol]=[[file,line,1]] 
			continue
		done=False
		# iterate over all warnings about this symbols we've had so far in this run
		for ww in D1[symbol]:
			if ww[0]!=file: continue
			if ww[1]!=line: continue
			# only care if both filename and linenumber match: increment count
			ww[2]+=1
			done=True
		# otherwise create a new record
		if not done: D1[symbol].append([file,line,1])

logging.info('Total number of %d deprecation warnings processed.'%Dcount)

#############################################################################################################################
## now go ahead and modify sources... :-( scared? huh, there will be many safety checks on the way, don't worry...
##

buildRoot=sys.argv[1]
# reoarganize D, so that it is hashed by (file,line) and contains (symbol,count)
F={}
Fcount=0
for symbol in D.keys():
	for ss in D[symbol]:
		file,line,count=ss
		if not F.has_key((file,line)):
			F[file,line]=[(symbol,count)]
			Fcount+=count
		else:
			for sss in F[file,line]: # can't have the same symbol twice...
				assert(sss!=symbol,count)
			F[file,line].append((symbol,count))
			Fcount+=count

logging.info('Merged into the total of %d usages of deprecated functions'%Fcount)

# files that we will have to modify
fileList=[]
for f,l in F.keys():
	if not f in fileList: fileList.append(f)
logging.info('%d files to be modified'%len(fileList))

for fName in fileList:
	origFile=join(buildRoot,fName)
	bcupFile=origFile+'.~undeprecated~'
	logging.info("Modifying file `%s' (%s); backup is `%s'."%(origFile,fName,bcupFile))
	# the first branch is normal run. The second one is a dry-run, where original files are not modified
	if 1:
		shutil.move(origFile,bcupFile)
		fout=open(origFile,'w')
		fin=open(bcupFile)
	else:
		fin=open(origFile)
		fout=open(bcupFile,'w')
	lineno=0
	for l in fin.xreadlines():
		lineno+=1
		if F.has_key((fName,lineno)):
			for symbol,count in F[fName,lineno]: # this has list of symbols and their counts on this particular line
				l2,subs=subn(r'\b'+symbol+r'\b',renamedSymbols[symbol],l) # try textual replace
				# make sure we have found exactly the same number of matches compiler told us about!
				# this is not the case if the expressions spans several lines or if there are local symbols with the same name as the deprecated method
				# some cases have been already handled by the Doffset custom dictionary above
				if subs!=count: 
					logging.error("%s:%d: Regexp found different number (%d) of `%s' than the compiler (%d). Fix by hand (replace by `%s'), please."%(fName,lineno,subs,symbol,count,renamedSymbols[symbol]))
				else:
					l=l2
		fout.write(l)









